{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"laminas-diactoros üá∑üá∫ –†—É—Å—Å–∫–∏–º –≥—Ä–∞–∂–¥–∞–Ω–∞–º –ú—ã, —É—á–∞—Å—Ç–Ω–∏–∫–∏ Laminas, —Ä–æ–¥–∏–ª–∏—Å—å –∏ –∂–∏–≤–µ–º –≤ —Ä–∞–∑–Ω—ã—Ö —Å—Ç—Ä–∞–Ω–∞—Ö. –£ –º–Ω–æ–≥–∏—Ö –∏–∑ –Ω–∞—Å –µ—Å—Ç—å –¥—Ä—É–∑—å—è, —Ä–æ–¥—Å—Ç–≤–µ–Ω–Ω–∏–∫–∏ –∏ –∫–æ–ª–ª–µ–≥–∏ –∫–∞–∫ –≤ –†–æ—Å—Å–∏–∏, —Ç–∞–∫ –∏ –≤ –£–∫—Ä–∞–∏–Ω–µ. –ù–µ–∫–æ—Ç–æ—Ä—ã–µ –∏–∑ –Ω–∞—Å —Ä–æ–¥–∏–ª–∏—Å—å –≤ –†–æ—Å—Å–∏–∏. –ù–µ–∫–æ—Ç–æ—Ä—ã–µ –∏–∑ –Ω–∞—Å –∂–∏–≤—É—Ç –≤ –†–æ—Å—Å–∏–∏. –£ –Ω–µ–∫–æ—Ç–æ—Ä—ã—Ö –±–∞–±—É—à–∫–∏ –∏ –¥–µ–¥—É—à–∫–∏ —Å—Ä–∞–∂–∞–ª–∏—Å—å —Å —Ñ–∞—à–∏—Å—Ç–∞–º–∏ –≤–æ –í—Ç–æ—Ä–æ–π –º–∏—Ä–æ–≤–æ–π –≤–æ–π–Ω–µ. –ó–¥–µ—Å—å –Ω–∏–∫—Ç–æ –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç —Ñ–∞—à–∏–∑–º. –£ –æ–¥–Ω–æ–≥–æ –∏–∑ –Ω–∞—Å –µ—Å—Ç—å —É–∫—Ä–∞–∏–Ω—Å–∫–∞—è —Ä–æ–¥—Å—Ç–≤–µ–Ω–Ω–∏—Ü–∞, –∫–æ—Ç–æ—Ä–∞—è —Å–ø–∞—Å–ª–∞—Å—å –∏–∑ –¥–æ–º–∞ –≤–º–µ—Å—Ç–µ —Å —Å—ã–Ω–æ–º. –ü–æ–µ–∑–¥ –∑–∞–¥–µ—Ä–∂–∞–ª—Å—è –∏–∑-–∑–∞ –±–æ–º–±–µ–∂–∫–∏ –Ω–∞ –¥–æ—Ä–æ–≥–µ –≤–ø–µ—Ä–µ–¥–∏. –£ –Ω–∞—Å –µ—Å—Ç—å –¥—Ä—É–∑—å—è, –∫–æ—Ç–æ—Ä—ã–µ –ø—Ä—è—á—É—Ç—Å—è –≤ –±–æ–º–±–æ—É–±–µ–∂–∏—â–∞—Ö. –ú—ã —Å —Ç—Ä–µ–≤–æ–≥–æ–π –∂–¥–µ–º –≤–µ—Å—Ç–æ—á–∫–∏ –æ—Ç –Ω–∏—Ö –ø–æ—Å–ª–µ –≤–æ–∑–¥—É—à–Ω—ã—Ö –Ω–∞–ª–µ—Ç–æ–≤, –∫–æ—Ç–æ—Ä—ã–µ –±–µ—Å–ø–æ—Ä—è–¥–æ—á–Ω–æ –Ω–∞–Ω–æ—Å—è—Ç —É–¥–∞—Ä—ã –∏ –ø–æ–ø–∞–¥–∞—é—Ç –ø–æ –±–æ–ª—å–Ω–∏—Ü–∞–º, —à–∫–æ–ª–∞–º, –¥–µ—Ç—Å–∫–∏–º —Å–∞–¥–∞–º –∏ –¥–æ–º–∞–º. –ú—ã –Ω–µ –±–µ—Ä–µ–º —ç—Ç–æ –∏–∑ –∫–∞–∫–∏—Ö-–ª–∏–±–æ –°–ú–ò. –ú—ã –Ω–∞–±–ª—é–¥–∞–µ–º —ç—Ç–æ –Ω–∞–ø—Ä—è–º—É—é. –í—ã –¥–æ–≤–µ—Ä—è–µ—Ç–µ –Ω–∞–º –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ, —á—Ç–æ–± –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –Ω–∞—à–∏ –ø—Ä–æ–≥—Ä–∞–º–º—ã, –∏ –º—ã –ø—Ä–æ—Å–∏–º –≤–∞—Å –¥–æ–≤–µ—Ä–∏—Ç—å—Å—è –Ω–∞–º –≤–Ω–æ–≤—å. –ú—ã –Ω—É–∂–¥–∞–µ–º—Å—è –≤ –ø–æ–º–æ—â–∏. –í—ã—Ö–æ–¥–∏—Ç–µ –∏ –ø—Ä–æ—Ç–µ—Å—Ç—É–π—Ç–µ –ø—Ä–æ—Ç–∏–≤ —ç—Ç–æ–π –±–µ—Å–ø–æ–ª–µ–∑–Ω–æ–π –≤–æ–π–Ω—ã. –û—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ –∫—Ä–æ–≤–æ–ø—Ä–æ–ª–∏—Ç–∏–µ. –°–∫–∞–∂–∏—Ç–µ \"–ù–µ—Ç –≤–æ–π–Ω–µ!\" üá∫üá∏ To Citizens of Russia We at Laminas come from all over the world. Many of us have friends, family and colleagues in both Russia and Ukraine. Some of us were born in Russia. Some of us currently live in Russia. Some have grandparents who fought Nazis in World War II. Nobody here supports fascism. One team member has a Ukrainian relative who fled her home with her son. The train was delayed due to bombing on the road ahead. We have friends who are hiding in bomb shelters. We anxiously follow up on them after the air raids, which indiscriminately fire at hospitals, schools, kindergartens and houses. We're not taking this from any media. These are our actual experiences. You trust us enough to use our software. We ask that you trust us to say the truth on this. We need your help. Go out and protest this unnecessary war. Stop the bloodshed. Say \"stop the war!\" Diactoros (pronunciation: /d…™ åkt…ír…ís/ ): an epithet for Hermes, meaning literally, \"the messenger.\" This package supercedes and replaces phly/http . laminas-diactoros is a PHP package containing implementations of the PSR-7 HTTP message interfaces and PSR-17 HTTP message factory interfaces . File issues at https://github.com/laminas/laminas-diactoros/issues Issue patches to https://github.com/laminas/laminas-diactoros/pulls Documentation Documentation is available at: https://docs.laminas.dev/laminas-diactoros/ Source files for documentation are in the docs/ tree . Contributing and Support If you need support with the project, read the support documentation . If you wish to contribute to the project, read the contributing guidelines as well as the Code of Conduct . For reporting security issues, please review our security policy .","title":"Home"},{"location":"#laminas-diactoros","text":"","title":"laminas-diactoros"},{"location":"#_1","text":"–ú—ã, —É—á–∞—Å—Ç–Ω–∏–∫–∏ Laminas, —Ä–æ–¥–∏–ª–∏—Å—å –∏ –∂–∏–≤–µ–º –≤ —Ä–∞–∑–Ω—ã—Ö —Å—Ç—Ä–∞–Ω–∞—Ö. –£ –º–Ω–æ–≥–∏—Ö –∏–∑ –Ω–∞—Å –µ—Å—Ç—å –¥—Ä—É–∑—å—è, —Ä–æ–¥—Å—Ç–≤–µ–Ω–Ω–∏–∫–∏ –∏ –∫–æ–ª–ª–µ–≥–∏ –∫–∞–∫ –≤ –†–æ—Å—Å–∏–∏, —Ç–∞–∫ –∏ –≤ –£–∫—Ä–∞–∏–Ω–µ. –ù–µ–∫–æ—Ç–æ—Ä—ã–µ –∏–∑ –Ω–∞—Å —Ä–æ–¥–∏–ª–∏—Å—å –≤ –†–æ—Å—Å–∏–∏. –ù–µ–∫–æ—Ç–æ—Ä—ã–µ –∏–∑ –Ω–∞—Å –∂–∏–≤—É—Ç –≤ –†–æ—Å—Å–∏–∏. –£ –Ω–µ–∫–æ—Ç–æ—Ä—ã—Ö –±–∞–±—É—à–∫–∏ –∏ –¥–µ–¥—É—à–∫–∏ —Å—Ä–∞–∂–∞–ª–∏—Å—å —Å —Ñ–∞—à–∏—Å—Ç–∞–º–∏ –≤–æ –í—Ç–æ—Ä–æ–π –º–∏—Ä–æ–≤–æ–π –≤–æ–π–Ω–µ. –ó–¥–µ—Å—å –Ω–∏–∫—Ç–æ –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç —Ñ–∞—à–∏–∑–º. –£ –æ–¥–Ω–æ–≥–æ –∏–∑ –Ω–∞—Å –µ—Å—Ç—å —É–∫—Ä–∞–∏–Ω—Å–∫–∞—è —Ä–æ–¥—Å—Ç–≤–µ–Ω–Ω–∏—Ü–∞, –∫–æ—Ç–æ—Ä–∞—è —Å–ø–∞—Å–ª–∞—Å—å –∏–∑ –¥–æ–º–∞ –≤–º–µ—Å—Ç–µ —Å —Å—ã–Ω–æ–º. –ü–æ–µ–∑–¥ –∑–∞–¥–µ—Ä–∂–∞–ª—Å—è –∏–∑-–∑–∞ –±–æ–º–±–µ–∂–∫–∏ –Ω–∞ –¥–æ—Ä–æ–≥–µ –≤–ø–µ—Ä–µ–¥–∏. –£ –Ω–∞—Å –µ—Å—Ç—å –¥—Ä—É–∑—å—è, –∫–æ—Ç–æ—Ä—ã–µ –ø—Ä—è—á—É—Ç—Å—è –≤ –±–æ–º–±–æ—É–±–µ–∂–∏—â–∞—Ö. –ú—ã —Å —Ç—Ä–µ–≤–æ–≥–æ–π –∂–¥–µ–º –≤–µ—Å—Ç–æ—á–∫–∏ –æ—Ç –Ω–∏—Ö –ø–æ—Å–ª–µ –≤–æ–∑–¥—É—à–Ω—ã—Ö –Ω–∞–ª–µ—Ç–æ–≤, –∫–æ—Ç–æ—Ä—ã–µ –±–µ—Å–ø–æ—Ä—è–¥–æ—á–Ω–æ –Ω–∞–Ω–æ—Å—è—Ç —É–¥–∞—Ä—ã –∏ –ø–æ–ø–∞–¥–∞—é—Ç –ø–æ –±–æ–ª—å–Ω–∏—Ü–∞–º, —à–∫–æ–ª–∞–º, –¥–µ—Ç—Å–∫–∏–º —Å–∞–¥–∞–º –∏ –¥–æ–º–∞–º. –ú—ã –Ω–µ –±–µ—Ä–µ–º —ç—Ç–æ –∏–∑ –∫–∞–∫–∏—Ö-–ª–∏–±–æ –°–ú–ò. –ú—ã –Ω–∞–±–ª—é–¥–∞–µ–º —ç—Ç–æ –Ω–∞–ø—Ä—è–º—É—é. –í—ã –¥–æ–≤–µ—Ä—è–µ—Ç–µ –Ω–∞–º –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ, —á—Ç–æ–± –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –Ω–∞—à–∏ –ø—Ä–æ–≥—Ä–∞–º–º—ã, –∏ –º—ã –ø—Ä–æ—Å–∏–º –≤–∞—Å –¥–æ–≤–µ—Ä–∏—Ç—å—Å—è –Ω–∞–º –≤–Ω–æ–≤—å. –ú—ã –Ω—É–∂–¥–∞–µ–º—Å—è –≤ –ø–æ–º–æ—â–∏. –í—ã—Ö–æ–¥–∏—Ç–µ –∏ –ø—Ä–æ—Ç–µ—Å—Ç—É–π—Ç–µ –ø—Ä–æ—Ç–∏–≤ —ç—Ç–æ–π –±–µ—Å–ø–æ–ª–µ–∑–Ω–æ–π –≤–æ–π–Ω—ã. –û—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ –∫—Ä–æ–≤–æ–ø—Ä–æ–ª–∏—Ç–∏–µ. –°–∫–∞–∂–∏—Ç–µ \"–ù–µ—Ç –≤–æ–π–Ω–µ!\"","title":"üá∑üá∫ –†—É—Å—Å–∫–∏–º –≥—Ä–∞–∂–¥–∞–Ω–∞–º"},{"location":"#to-citizens-of-russia","text":"We at Laminas come from all over the world. Many of us have friends, family and colleagues in both Russia and Ukraine. Some of us were born in Russia. Some of us currently live in Russia. Some have grandparents who fought Nazis in World War II. Nobody here supports fascism. One team member has a Ukrainian relative who fled her home with her son. The train was delayed due to bombing on the road ahead. We have friends who are hiding in bomb shelters. We anxiously follow up on them after the air raids, which indiscriminately fire at hospitals, schools, kindergartens and houses. We're not taking this from any media. These are our actual experiences. You trust us enough to use our software. We ask that you trust us to say the truth on this. We need your help. Go out and protest this unnecessary war. Stop the bloodshed. Say \"stop the war!\" Diactoros (pronunciation: /d…™ åkt…ír…ís/ ): an epithet for Hermes, meaning literally, \"the messenger.\" This package supercedes and replaces phly/http . laminas-diactoros is a PHP package containing implementations of the PSR-7 HTTP message interfaces and PSR-17 HTTP message factory interfaces . File issues at https://github.com/laminas/laminas-diactoros/issues Issue patches to https://github.com/laminas/laminas-diactoros/pulls","title":"üá∫üá∏ To Citizens of Russia"},{"location":"#documentation","text":"Documentation is available at: https://docs.laminas.dev/laminas-diactoros/ Source files for documentation are in the docs/ tree .","title":"Documentation"},{"location":"#contributing-and-support","text":"If you need support with the project, read the support documentation . If you wish to contribute to the project, read the contributing guidelines as well as the Code of Conduct . For reporting security issues, please review our security policy .","title":"Contributing and Support"},{"location":"v1/api/","text":"API Request Message Laminas\\Diactoros\\Request implements Psr\\Http\\Message\\RequestInterface , and is intended for client-side requests. It includes the following methods: class Request { public function __construct( $uri = null, $method = null, $body = 'php://memory', array $headers = [] ); // See psr/http-message's RequestInterface for other methods } Requests are immutable. Any methods that would change state ‚Äî those prefixed with with and without ‚Äî all return a new instance with the changes requested. ServerRequest Message For server-side applications, Laminas\\Diactoros\\ServerRequest implements Psr\\Http\\Message\\ServerRequestInterface , which provides access to the elements of an HTTP request, as well as uniform access to the various elements of incoming data. The methods included are: class ServerRequest { public function __construct( array $serverParams = [], array $fileParams = [], $uri = null, $method = null, $body = 'php://input', array $headers = [] ); // See psr/http-message's ServerRequestInterface for other methods. } The ServerRequest is immutable. Any methods that would change state ‚Äî those prefixed with with and without ‚Äî all return a new instance with the changes requested. Server parameters are considered completely immutable, however, as they cannot be recalculated, and, rather, is a source for other values. Response Message Laminas\\Diactoros\\Response provides an implementation of Psr\\Http\\Message\\ResponseInterface , an object to be used to aggregate response information for both HTTP clients and server-side applications, including headers and message body content. It includes the following: class Response { public function __construct( $body = 'php://memory', $statusCode = 200, array $headers = [] ); // See psr/http-message's ResponseInterface for other methods } Like the Request and ServerRequest , responses are immutable. Any methods that would change state ‚Äî those prefixed with with and without ‚Äî all return a new instance with the changes requested. HtmlResponse and JsonResponse Available since version 1.1.0 The most common use case in server-side applications for generating responses is to provide a string to use for the response, typically HTML or data to serialize as JSON. Laminas\\Diactoros\\Response\\HtmlResponse and Laminas\\Diactoros\\Response\\JsonResponse exist to facilitate these use cases: $htmlResponse = new HtmlResponse($html); $jsonResponse = new JsonResponse($data); In the first example, you will receive a response with a stream containing the HTML; additionally, the Content-Type header will be set to text/html . In the second case, the stream will contain a stream containing the JSON-serialized $data , and have a Content-Type header set to application/json . Both objects allow passing the HTTP status, as well as any headers you want to specify, including the Content-Type header: $htmlResponse = new HtmlResponse($html, 404, [ 'Content-Type' =&gt; [ 'application/xhtml+xml' ], ]); $jsonResponse = new JsonResponse($data, 422, [ 'Content-Type' =&gt; [ 'application/problem+json' ], ]); ServerRequestFactory This static class can be used to marshal a ServerRequest instance from the PHP environment. The primary entry point is Laminas\\Diactoros\\ServerRequestFactory::fromGlobals(array $server, array $query, array $body, array $cookies, array $files) . This method will create a new ServerRequest instance with the data provided. Examples of usage are: // Returns new ServerRequest instance, using values from superglobals: $request = ServerRequestFactory::fromGlobals(); // or // Returns new ServerRequest instance, using values provided (in this // case, equivalent to the previous!) $request = ServerRequestFactory::fromGlobals( $_SERVER, $_GET, $_POST, $_COOKIE, $_FILES ); ServerRequestFactory Helper Functions Available since version 1.8.0 In order to create the various artifacts required by a ServerRequest instance, Diactoros also provides a number of functions under the Laminas\\Diactoros namespace for introspecting the SAPI $_SERVER parameters, headers, $_FILES , and even the Cookie header. These include: Laminas\\Diactoros\\normalizeServer(array $server, callable $apacheRequestHeaderCallback = null) : array (its main purpose is to aggregate the Authorization header in the SAPI params when under Apache) Laminas\\Diactoros\\marshalProtocolVersionFromSapi(array $server) : string Laminas\\Diactoros\\marshalMethodFromSapi(array $server) : string Laminas\\Diactoros\\marshalUriFromSapi(array $server, array $headers) : Uri Laminas\\Diactoros\\marshalHeadersFromSapi(array $server) : array Laminas\\Diactoros\\parseCookieHeader(string $header) : array Laminas\\Diactoros\\createUploadedFile(array $spec) : UploadedFile (creates the instance from a normal $_FILES entry) Laminas\\Diactoros\\normalizeUploadedFiles(array $files) : UploadedFileInterface[] (traverses a potentially nested array of uploaded file instances and/or $_FILES entries, including those aggregated under mod_php, php-fpm, and php-cgi in order to create a flat array of UploadedFileInterface instances to use in a request) URI Laminas\\Diactoros\\Uri is an implementation of Psr\\Http\\Message\\UriInterface , and models and validates URIs. It implements __toString() , allowing it to be represented as a string and echo() 'd directly. The following methods are pertinent: class Uri { public function __construct($uri = ''); // See psr/http-message's UriInterface for other methods. } Like the various message objects, URIs are immutable. Any methods that would change state ‚Äî those prefixed with with and without ‚Äî all return a new instance with the changes requested. Stream Laminas\\Diactoros\\Stream is an implementation of Psr\\Http\\Message\\StreamInterface , and provides a number of facilities around manipulating the composed PHP stream resource. The constructor accepts a stream, which may be either: a stream identifier; e.g., php://input , a filename, etc. a PHP stream resource If a stream identifier is provided, an optional second parameter may be provided, the file mode by which to fopen the stream. ServerRequest objects by default use a php://input stream set to read-only; Response objects by default use a php://memory with a mode of wb+ , allowing binary read/write access. In most cases, you will not interact with the Stream object directly. UploadedFile Laminas\\Diactoros\\UploadedFile is an implementation of Psr\\Http\\Message\\UploadedFileInterface , and provides abstraction around a single uploaded file, including behavior for interacting with it as a stream or moving it to a filesystem location. In most cases, you will only use the methods defined in the UploadedFileInterface . Server Deprecated The class Laminas\\Diactoros\\Server is deprecated as of the 1.8.0 release. We recommend using the class Laminas\\HttpHandlerRunner\\RequestHandlerRunner via the package laminas/laminas-httphandlerrunner instead. Laminas\\Diactoros\\Server represents a server capable of executing a callback. It has four methods: class Server { public function __construct( callable $callback, Psr\\Http\\Message\\ServerRequestInterface $request, Psr\\Http\\Message\\ResponseInterface $response ); public static function createServer( callable $callback, array $server, // usually $_SERVER array $query, // usually $_GET array $body, // usually $_POST array $cookies, // usually $_COOKIE array $files // usually $_FILES ); public static function createServerFromRequest( callable $callback, Psr\\Http\\Message\\ServerRequestInterface $request, Psr\\Http\\Message\\ResponseInterface $response = null ); public function setEmitter(Response\\EmitterInterface $emitter); public function listen(callable $finalHandler = null); } You can create an instance of the Server using any of the constructor, createServer() , or createServerFromRequest() methods. If you wish to use the default request and response implementations, createServer($middleware, $_SERVER, $_GET, $_POST, $_COOKIE, $_FILES) is the recommended option, as this method will also marshal the ServerRequest object based on the PHP request environment. If you wish to use your own implementations, pass them to the constructor or createServerFromRequest() method (the latter will create a default Response instance if you omit it). listen() executes the callback. If a $finalHandler is provided, it will be passed as the third argument to the $callback registered with the server.","title":"API"},{"location":"v1/api/#api","text":"","title":"API"},{"location":"v1/api/#request-message","text":"Laminas\\Diactoros\\Request implements Psr\\Http\\Message\\RequestInterface , and is intended for client-side requests. It includes the following methods: class Request { public function __construct( $uri = null, $method = null, $body = 'php://memory', array $headers = [] ); // See psr/http-message's RequestInterface for other methods } Requests are immutable. Any methods that would change state ‚Äî those prefixed with with and without ‚Äî all return a new instance with the changes requested.","title":"Request Message"},{"location":"v1/api/#serverrequest-message","text":"For server-side applications, Laminas\\Diactoros\\ServerRequest implements Psr\\Http\\Message\\ServerRequestInterface , which provides access to the elements of an HTTP request, as well as uniform access to the various elements of incoming data. The methods included are: class ServerRequest { public function __construct( array $serverParams = [], array $fileParams = [], $uri = null, $method = null, $body = 'php://input', array $headers = [] ); // See psr/http-message's ServerRequestInterface for other methods. } The ServerRequest is immutable. Any methods that would change state ‚Äî those prefixed with with and without ‚Äî all return a new instance with the changes requested. Server parameters are considered completely immutable, however, as they cannot be recalculated, and, rather, is a source for other values.","title":"ServerRequest Message"},{"location":"v1/api/#response-message","text":"Laminas\\Diactoros\\Response provides an implementation of Psr\\Http\\Message\\ResponseInterface , an object to be used to aggregate response information for both HTTP clients and server-side applications, including headers and message body content. It includes the following: class Response { public function __construct( $body = 'php://memory', $statusCode = 200, array $headers = [] ); // See psr/http-message's ResponseInterface for other methods } Like the Request and ServerRequest , responses are immutable. Any methods that would change state ‚Äî those prefixed with with and without ‚Äî all return a new instance with the changes requested.","title":"Response Message"},{"location":"v1/api/#serverrequestfactory","text":"This static class can be used to marshal a ServerRequest instance from the PHP environment. The primary entry point is Laminas\\Diactoros\\ServerRequestFactory::fromGlobals(array $server, array $query, array $body, array $cookies, array $files) . This method will create a new ServerRequest instance with the data provided. Examples of usage are: // Returns new ServerRequest instance, using values from superglobals: $request = ServerRequestFactory::fromGlobals(); // or // Returns new ServerRequest instance, using values provided (in this // case, equivalent to the previous!) $request = ServerRequestFactory::fromGlobals( $_SERVER, $_GET, $_POST, $_COOKIE, $_FILES );","title":"ServerRequestFactory"},{"location":"v1/api/#uri","text":"Laminas\\Diactoros\\Uri is an implementation of Psr\\Http\\Message\\UriInterface , and models and validates URIs. It implements __toString() , allowing it to be represented as a string and echo() 'd directly. The following methods are pertinent: class Uri { public function __construct($uri = ''); // See psr/http-message's UriInterface for other methods. } Like the various message objects, URIs are immutable. Any methods that would change state ‚Äî those prefixed with with and without ‚Äî all return a new instance with the changes requested.","title":"URI"},{"location":"v1/api/#stream","text":"Laminas\\Diactoros\\Stream is an implementation of Psr\\Http\\Message\\StreamInterface , and provides a number of facilities around manipulating the composed PHP stream resource. The constructor accepts a stream, which may be either: a stream identifier; e.g., php://input , a filename, etc. a PHP stream resource If a stream identifier is provided, an optional second parameter may be provided, the file mode by which to fopen the stream. ServerRequest objects by default use a php://input stream set to read-only; Response objects by default use a php://memory with a mode of wb+ , allowing binary read/write access. In most cases, you will not interact with the Stream object directly.","title":"Stream"},{"location":"v1/api/#uploadedfile","text":"Laminas\\Diactoros\\UploadedFile is an implementation of Psr\\Http\\Message\\UploadedFileInterface , and provides abstraction around a single uploaded file, including behavior for interacting with it as a stream or moving it to a filesystem location. In most cases, you will only use the methods defined in the UploadedFileInterface .","title":"UploadedFile"},{"location":"v1/api/#server","text":"","title":"Server"},{"location":"v1/custom-responses/","text":"Custom Responses When developing server-side applications, the message type you're most likely to create manually is the response. In such cases, the standard signature can be an obstacle to usability. Let's review: class Response implements ResponseInterface { public function __construct($body = 'php://temp', $status = 200, array $headers = []); } Some standard use cases, however, make this un-wieldy: Returning a response containing HTML; in this case, you likely want to provide the HTML to the constructor, not a stream with the HTML injected. Returning a response containing JSON; in this case, you likely want to provide the data to serialize to JSON, not a stream containing serialized JSON. Returning a response with no content; in this case, you don't want to bother with the body at all. Returning a redirect response; in this case, you likely just want to specify the target for the Location header, and optionally the status code. Starting with version 1.1, Diactoros offers several custom response types for simplifying these common tasks. Text Responses Laminas\\Diactoros\\Response\\TextResponse creates a plain text response. It sets the Content-Type header to text/plain by default: $response = new TextResponse('Hello world!'); The constructor accepts two additional arguments: a status code and an array of headers. $response = new TextResponse($text, 200, ['Content-Type' =&gt; ['text/csv']]); HTML Responses Laminas\\Diactoros\\Response\\HtmlResponse allows specifying HTML as a payload, and sets the Content-Type header to text/html by default: $response = new HtmlResponse($htmlContent); The constructor allows passing two additional arguments: a status code, and an array of headers. These allow you to further seed the initial state of the response, as well as to override the Content-Type header if desired: $response = new HtmlResponse($htmlContent, 200, [ 'Content-Type' =&gt; ['application/xhtml+xml']]); Headers must be in the same format as you would provide to the Response constructor . XML Responses Available since version 1.7.0 Laminas\\Diactoros\\Response\\XmlResponse allows specifying XML as a payload, and sets the Content-Type header to application/xml by default: $response = new XmlResponse($xml); The constructor allows passing two additional arguments: a status code, and an array of headers. These allow you to further seed the initial state of the response, as well as to override the Content-Type header if desired: $response = new XmlResponse($xml, 200, [ 'Content-Type' =&gt; ['application/hal+xml']]); Headers must be in the same format as you would provide to the Response constructor . JSON Responses Laminas\\Diactoros\\Response\\JsonResponse accepts a data structure to convert to JSON, and sets the Content-Type header to application/json : $response = new JsonResponse($data); If providing an object, we recommend implementing JsonSerializable to ensure your object is correctly serialized. Just like the HtmlResponse , the JsonResponse allows passing two additional arguments ‚Äî a status code, and an array of headers ‚Äî to allow you to further seed the initial state of the response: $response = new JsonResponse($data, 200, [ 'Content-Type' =&gt; ['application/hal+json']]); Finally, JsonResponse allows a fourth optional argument, the flags to provide to json_encode() . By default, these are set to JSON_HEX_TAG | JSON_HEX_APOS | JSON_HEX_AMP | JSON_HEX_QUOT (integer 15), providing RFC 4627 compliant JSON capable of embedding in HTML. If you want to specify a different set of flags, use the fourth constructor argument: $response = new JsonResponse( $data, 200, [], JSON_PRETTY_PRINT | JSON_HEX_TAG | JSON_HEX_APOS | JSON_HEX_AMP | JSON_HEX_QUOT ); Empty Responses Many API actions allow returning empty responses: 201 Created responses are often empty, and only include a Link or Location header pointing to the newly created resource. 202 Accepted responses are typically empty, indicating that the new entity has been received, but not yet processed. 204 No Content responses are, by definition, empty, and often used as a success response when deleting an entity. Laminas\\Diactoros\\Response\\EmptyResponse is a Laminas\\Diactoros\\Response extension that, by default, returns an empty response with a 204 status. Its constructor allows passing the status and headers only: class EmptyResponse extends Response { public function __construct($status = 204, array $headers = []); } An empty, read-only body is injected at instantiation, ensuring no write operations are possible on the response. Usage is typically one of the following forms: // Basic 204 response: $response = new EmptyResponse(); // 201 response with location header: $response = new EmptyResponse(201, [ 'Location' =&gt; [ $url ], ]); // Alternately, set the header after instantiation: $response = ( new EmptyResponse(201) )-&gt;withHeader('Location', $url); Redirects Laminas\\Diactoros\\Response\\RedirectResponse is a Laminas\\Diactoros\\Response extension for producing redirect responses. The only required argument is a URI, which may be provided as either a string or Psr\\Http\\Message\\UriInterface instance. By default, the status 302 is used, and no other headers are produced; you may alter these via the additional optional arguments: class RedirectResponse extends Response { public function __construct($uri, $status = 302, array $headers = []); } Typical usage is: // 302 redirect: $response = new RedirectResponse('/user/login'); // 301 redirect: $response = new RedirectResponse('/user/login', 301); // using a URI instance (e.g., by altering the request URI instance) $uri = $request-&gt;getUri(); $response = new RedirectResponse($uri-&gt;withPath('/login')); Creating custom Responses PHP allows constructor overloading. What this means is that constructors of extending classes can define completely different argument sets without conflicting with the parent implementation. Considering that most custom response types do not need to change internal functionality, but instead focus on user experience (i.e., simplifying instantiation), this fact can be leveraged to create your custom types. The general pattern will be something like this: class MyCustomResponse extends Response { public function __construct($data, $status = 200, array $headers = []) { // - Do something with $data, and create a Stream for the body (if necessary). // - Maybe set some default headers. parent::__construct($body, $status, $headers); } } Note the call to parent::__construct() . This is particularly relevant, as the implementation at the time of writing has all class properties marked as private, making them inaccessible to extensions; this is done to protect encapsulation and ensure consistency of operations between instances. If you don't want to go the extension route (perhaps you don't want another ResponseInterface implementation within your object graph) you can instead create a factory. As an example: $plainTextResponse = function ($text, $status = 200, array $headers = []) { $response = new Response('php://temp', $status, $headers); $response-&gt;getBody()-&gt;write($text); if (! $response-&gt;hasHeader('Content-Type')) { $response = $response-&gt;withHeader('Content-Type', 'text/plain'); } return $response; }; $response = $plainTextResponse('Hello, world!'); We recommend following the semantic of providing the status and headers as the final two arguments for any factory or custom response extensions.","title":"Custom Responses"},{"location":"v1/custom-responses/#custom-responses","text":"When developing server-side applications, the message type you're most likely to create manually is the response. In such cases, the standard signature can be an obstacle to usability. Let's review: class Response implements ResponseInterface { public function __construct($body = 'php://temp', $status = 200, array $headers = []); } Some standard use cases, however, make this un-wieldy: Returning a response containing HTML; in this case, you likely want to provide the HTML to the constructor, not a stream with the HTML injected. Returning a response containing JSON; in this case, you likely want to provide the data to serialize to JSON, not a stream containing serialized JSON. Returning a response with no content; in this case, you don't want to bother with the body at all. Returning a redirect response; in this case, you likely just want to specify the target for the Location header, and optionally the status code. Starting with version 1.1, Diactoros offers several custom response types for simplifying these common tasks.","title":"Custom Responses"},{"location":"v1/custom-responses/#text-responses","text":"Laminas\\Diactoros\\Response\\TextResponse creates a plain text response. It sets the Content-Type header to text/plain by default: $response = new TextResponse('Hello world!'); The constructor accepts two additional arguments: a status code and an array of headers. $response = new TextResponse($text, 200, ['Content-Type' =&gt; ['text/csv']]);","title":"Text Responses"},{"location":"v1/custom-responses/#html-responses","text":"Laminas\\Diactoros\\Response\\HtmlResponse allows specifying HTML as a payload, and sets the Content-Type header to text/html by default: $response = new HtmlResponse($htmlContent); The constructor allows passing two additional arguments: a status code, and an array of headers. These allow you to further seed the initial state of the response, as well as to override the Content-Type header if desired: $response = new HtmlResponse($htmlContent, 200, [ 'Content-Type' =&gt; ['application/xhtml+xml']]); Headers must be in the same format as you would provide to the Response constructor .","title":"HTML Responses"},{"location":"v1/custom-responses/#xml-responses","text":"Available since version 1.7.0 Laminas\\Diactoros\\Response\\XmlResponse allows specifying XML as a payload, and sets the Content-Type header to application/xml by default: $response = new XmlResponse($xml); The constructor allows passing two additional arguments: a status code, and an array of headers. These allow you to further seed the initial state of the response, as well as to override the Content-Type header if desired: $response = new XmlResponse($xml, 200, [ 'Content-Type' =&gt; ['application/hal+xml']]); Headers must be in the same format as you would provide to the Response constructor .","title":"XML Responses"},{"location":"v1/custom-responses/#json-responses","text":"Laminas\\Diactoros\\Response\\JsonResponse accepts a data structure to convert to JSON, and sets the Content-Type header to application/json : $response = new JsonResponse($data); If providing an object, we recommend implementing JsonSerializable to ensure your object is correctly serialized. Just like the HtmlResponse , the JsonResponse allows passing two additional arguments ‚Äî a status code, and an array of headers ‚Äî to allow you to further seed the initial state of the response: $response = new JsonResponse($data, 200, [ 'Content-Type' =&gt; ['application/hal+json']]); Finally, JsonResponse allows a fourth optional argument, the flags to provide to json_encode() . By default, these are set to JSON_HEX_TAG | JSON_HEX_APOS | JSON_HEX_AMP | JSON_HEX_QUOT (integer 15), providing RFC 4627 compliant JSON capable of embedding in HTML. If you want to specify a different set of flags, use the fourth constructor argument: $response = new JsonResponse( $data, 200, [], JSON_PRETTY_PRINT | JSON_HEX_TAG | JSON_HEX_APOS | JSON_HEX_AMP | JSON_HEX_QUOT );","title":"JSON Responses"},{"location":"v1/custom-responses/#empty-responses","text":"Many API actions allow returning empty responses: 201 Created responses are often empty, and only include a Link or Location header pointing to the newly created resource. 202 Accepted responses are typically empty, indicating that the new entity has been received, but not yet processed. 204 No Content responses are, by definition, empty, and often used as a success response when deleting an entity. Laminas\\Diactoros\\Response\\EmptyResponse is a Laminas\\Diactoros\\Response extension that, by default, returns an empty response with a 204 status. Its constructor allows passing the status and headers only: class EmptyResponse extends Response { public function __construct($status = 204, array $headers = []); } An empty, read-only body is injected at instantiation, ensuring no write operations are possible on the response. Usage is typically one of the following forms: // Basic 204 response: $response = new EmptyResponse(); // 201 response with location header: $response = new EmptyResponse(201, [ 'Location' =&gt; [ $url ], ]); // Alternately, set the header after instantiation: $response = ( new EmptyResponse(201) )-&gt;withHeader('Location', $url);","title":"Empty Responses"},{"location":"v1/custom-responses/#redirects","text":"Laminas\\Diactoros\\Response\\RedirectResponse is a Laminas\\Diactoros\\Response extension for producing redirect responses. The only required argument is a URI, which may be provided as either a string or Psr\\Http\\Message\\UriInterface instance. By default, the status 302 is used, and no other headers are produced; you may alter these via the additional optional arguments: class RedirectResponse extends Response { public function __construct($uri, $status = 302, array $headers = []); } Typical usage is: // 302 redirect: $response = new RedirectResponse('/user/login'); // 301 redirect: $response = new RedirectResponse('/user/login', 301); // using a URI instance (e.g., by altering the request URI instance) $uri = $request-&gt;getUri(); $response = new RedirectResponse($uri-&gt;withPath('/login'));","title":"Redirects"},{"location":"v1/custom-responses/#creating-custom-responses","text":"PHP allows constructor overloading. What this means is that constructors of extending classes can define completely different argument sets without conflicting with the parent implementation. Considering that most custom response types do not need to change internal functionality, but instead focus on user experience (i.e., simplifying instantiation), this fact can be leveraged to create your custom types. The general pattern will be something like this: class MyCustomResponse extends Response { public function __construct($data, $status = 200, array $headers = []) { // - Do something with $data, and create a Stream for the body (if necessary). // - Maybe set some default headers. parent::__construct($body, $status, $headers); } } Note the call to parent::__construct() . This is particularly relevant, as the implementation at the time of writing has all class properties marked as private, making them inaccessible to extensions; this is done to protect encapsulation and ensure consistency of operations between instances. If you don't want to go the extension route (perhaps you don't want another ResponseInterface implementation within your object graph) you can instead create a factory. As an example: $plainTextResponse = function ($text, $status = 200, array $headers = []) { $response = new Response('php://temp', $status, $headers); $response-&gt;getBody()-&gt;write($text); if (! $response-&gt;hasHeader('Content-Type')) { $response = $response-&gt;withHeader('Content-Type', 'text/plain'); } return $response; }; $response = $plainTextResponse('Hello, world!'); We recommend following the semantic of providing the status and headers as the final two arguments for any factory or custom response extensions.","title":"Creating custom Responses"},{"location":"v1/emitting-responses/","text":"Emitting Responses Introduction Deprecated Emitters are deprecated from Diactoros starting with version 1.8.0. The functionality is now available for any PSR-7 implementation via the package laminas/laminas-httphandlerrunner . We suggest using that functionality instead. If you are using a non-SAPI PHP implementation and wish to use the Server class, or if you do not want to use the Server implementation but want to emit a response, this package provides an interface, Laminas\\Diactoros\\Response\\EmitterInterface , defining a method emit() for emitting the response. Diactoros provides two implementations currently, both for working with traditional Server API (SAPI) implementations: Laminas\\Diactoros\\Response\\SapiEmitter and Laminas\\Diactoros\\Response\\SapiStreamEmitter . Each uses the native header() PHP function to emit headers, and echo() to emit the response body. If you are using a non-SAPI implementation, you will need to create your own EmitterInterface implementation. For example, the SapiEmitter implementation of the EmitterInterface can be used thus: $response = new Laminas\\Diactoros\\Response(); $response-&gt;getBody()-&gt;write(\"some content\\n\"); $emitter = new Laminas\\Diactoros\\Response\\SapiEmitter(); $emitter-&gt;emit($response); Emitting Ranges of streamed Files The SapiStreamEmitter is useful when you want to emit a Content-Range . As an example, to stream a range of bytes from a file to a client, the client can pass the following header: Range: bytes=1024-2047 Your application would then populate the response with a Content-Range header: $range = $request-&gt;getHeaderLine('range'); $range = str_replace('=', ' ', $range); $body = new Stream($pathToFile); $size = $body-&gt;getSize(); $range .= '/' . $size; $response = new Response($body); $response = $response-&gt;withHeader('Content-Range', $range); (Note: you will likely want to ensure the range specified falls within the content size of the streamed body!) The SapiStreamEmitter detects the Content-Range header and emits only the bytes specified. $emitter = new SapiStreamEmitter(); $emitter-&gt;emit($response); The SapiStreamEmitter may be used in place of the SapiEmitter , even when not sending files. However, unlike the SapiEmitter , it will emit a chunk of content at a time instead of the full content at once, which could lead to performance overhead. The default chunk size is 8192 bytes.","title":"Emitting Responses"},{"location":"v1/emitting-responses/#emitting-responses","text":"","title":"Emitting Responses"},{"location":"v1/emitting-responses/#introduction","text":"","title":"Introduction"},{"location":"v1/emitting-responses/#emitting-ranges-of-streamed-files","text":"The SapiStreamEmitter is useful when you want to emit a Content-Range . As an example, to stream a range of bytes from a file to a client, the client can pass the following header: Range: bytes=1024-2047 Your application would then populate the response with a Content-Range header: $range = $request-&gt;getHeaderLine('range'); $range = str_replace('=', ' ', $range); $body = new Stream($pathToFile); $size = $body-&gt;getSize(); $range .= '/' . $size; $response = new Response($body); $response = $response-&gt;withHeader('Content-Range', $range); (Note: you will likely want to ensure the range specified falls within the content size of the streamed body!) The SapiStreamEmitter detects the Content-Range header and emits only the bytes specified. $emitter = new SapiStreamEmitter(); $emitter-&gt;emit($response); The SapiStreamEmitter may be used in place of the SapiEmitter , even when not sending files. However, unlike the SapiEmitter , it will emit a chunk of content at a time instead of the full content at once, which could lead to performance overhead. The default chunk size is 8192 bytes.","title":"Emitting Ranges of streamed Files"},{"location":"v1/install/","text":"Installation Install this library using composer: $ composer require \"laminas/laminas-diactoros:^1.8.6\" laminas-diactoros has the following dependencies (which are managed by Composer): psr/http-message , which defines interfaces for HTTP messages, including requests and responses. laminas-diactoros provides implementations of each of these.","title":"Installation"},{"location":"v1/install/#installation","text":"Install this library using composer: $ composer require \"laminas/laminas-diactoros:^1.8.6\" laminas-diactoros has the following dependencies (which are managed by Composer): psr/http-message , which defines interfaces for HTTP messages, including requests and responses. laminas-diactoros provides implementations of each of these.","title":"Installation"},{"location":"v1/overview/","text":"Overview laminas-diactoros is a PHP package containing implementations of the accepted PSR-7 HTTP message interfaces , as well as a \"server\" implementation similar to node's http.Server . This package exists: to provide an implementation of PSR-7 HTTP message interfaces with relation to server-side applications. to provide a common methodology for marshaling a request from the server environment.","title":"Overview"},{"location":"v1/overview/#overview","text":"laminas-diactoros is a PHP package containing implementations of the accepted PSR-7 HTTP message interfaces , as well as a \"server\" implementation similar to node's http.Server . This package exists: to provide an implementation of PSR-7 HTTP message interfaces with relation to server-side applications. to provide a common methodology for marshaling a request from the server environment.","title":"Overview"},{"location":"v1/serialization/","text":"Serialization String At times, it's useful to either create a string representation of a message (serialization), or to cast a string or stream message to an object (deserialization). This package provides features for this in Laminas\\Diactoros\\Request\\Serializer and Laminas\\Diactoros\\Response\\Serializer ; each provides the following static methods: fromString($message) will create either a Request or Response instance (based on the serializer used) from the string message. fromStream(Psr\\Http\\Message\\StreamInterface $stream) will create either a Request or Response instance (based on the serializer used) from the provided stream. toString(Psr\\Http\\Message\\RequestInterface|Psr\\Http\\Message\\ResponseInterface $message) will create either a string from the provided message. The deserialization methods ( from*() ) will raise exceptions if errors occur while parsing the message. The serialization methods ( toString() ) will raise exceptions if required data for serialization is not present in the message instance. Array This package also provides features for array serialization using Laminas\\Diactoros\\Request\\ArraySerializer and Laminas\\Diactoros\\Response\\ArraySerializer ; each provides the following static methods: fromArray(array $message) will create either a Request or Response instance (based on the serializer used) from the array message. toArray(Psr\\Http\\Message\\RequestInterface|Psr\\Http\\Message\\ResponseInterface $message) will create an array from the provided message. The deserialization methods ( fromArray() ) will raise exceptions if errors occur while parsing the message. Example Usage Array serialization can be usesful for log messages: class LoggerMiddleware { /** * @var \\Psr\\Log\\LoggerInterface */ protected $logger; public function __invoke(ServerRequestInterface $request, ResponseInterface $response, callable $next) { $response = $next($request, $response); $this-&gt;logger-&gt;debug('Request/Response', [ 'request' =&gt; \\Laminas\\Diactoros\\Request\\ArraySerializer::toArray($request), 'response' =&gt; \\Laminas\\Diactoros\\Response\\ArraySerializer::toArray($response), ]); return $response; } }","title":"Serialization"},{"location":"v1/serialization/#serialization","text":"","title":"Serialization"},{"location":"v1/serialization/#string","text":"At times, it's useful to either create a string representation of a message (serialization), or to cast a string or stream message to an object (deserialization). This package provides features for this in Laminas\\Diactoros\\Request\\Serializer and Laminas\\Diactoros\\Response\\Serializer ; each provides the following static methods: fromString($message) will create either a Request or Response instance (based on the serializer used) from the string message. fromStream(Psr\\Http\\Message\\StreamInterface $stream) will create either a Request or Response instance (based on the serializer used) from the provided stream. toString(Psr\\Http\\Message\\RequestInterface|Psr\\Http\\Message\\ResponseInterface $message) will create either a string from the provided message. The deserialization methods ( from*() ) will raise exceptions if errors occur while parsing the message. The serialization methods ( toString() ) will raise exceptions if required data for serialization is not present in the message instance.","title":"String"},{"location":"v1/serialization/#array","text":"This package also provides features for array serialization using Laminas\\Diactoros\\Request\\ArraySerializer and Laminas\\Diactoros\\Response\\ArraySerializer ; each provides the following static methods: fromArray(array $message) will create either a Request or Response instance (based on the serializer used) from the array message. toArray(Psr\\Http\\Message\\RequestInterface|Psr\\Http\\Message\\ResponseInterface $message) will create an array from the provided message. The deserialization methods ( fromArray() ) will raise exceptions if errors occur while parsing the message.","title":"Array"},{"location":"v1/usage/","text":"Usage Usage will differ based on whether you are writing an HTTP client, or a server-side application. For HTTP client purposes, you will create and populate a Request instance, and the client should return a Response instance. For server-side applications, you will create a ServerRequest instance, and populate and return a Response instance. HTTP Clients A client will send a request, and return a response. As a developer, you will create and populate the request, and then introspect the response. Both requests and responses are immutable; if you make changes ‚Äî e.g., by calling setter methods ‚Äî you must capture the return value, as it is a new instance. // Create a request $request = (new Laminas\\Diactoros\\Request()) -&gt;withUri(new Laminas\\Diactoros\\Uri('http://example.com')) -&gt;withMethod('PATCH') -&gt;withAddedHeader('Authorization', 'Bearer ' . $token) -&gt;withAddedHeader('Content-Type', 'application/json'); // OR: $request = new Laminas\\Diactoros\\Request( 'http://example.com', 'PATCH', 'php://memory', [ 'Authorization' =&gt; 'Bearer ' . $token, 'Content-Type' =&gt; 'application/json', ] ); // If you want to set a non-origin-form request target, set the // request-target explicitly: $request = $request-&gt;withRequestTarget((string) $uri); // absolute-form $request = $request-&gt;withRequestTarget($uri-&gt;getAuthority()); // authority-form $request = $request-&gt;withRequestTarget('*'); // asterisk-form // Once you have the instance: $request-&gt;getBody()-&gt;write(json_encode($data)); $response = $client-&gt;send($request); printf(\"Response status: %d (%s)\\n\", $response-&gt;getStatusCode(), $response-&gt;getReasonPhrase()); printf(\"Headers:\\n\"); foreach ($response-&gt;getHeaders() as $header =&gt; $values) { printf(\" %s: %s\\n\", $header, implode(', ', $values)); } printf(\"Message:\\n%s\\n\", $response-&gt;getBody()); (Note: laminas-diactoros does NOT ship with a client implementation; the above is just an illustration of a possible implementation.) Server-Side Applications Server-side applications will need to marshal the incoming request based on superglobals, and will then populate and send a response. Marshaling an incoming Request PHP contains a plethora of information about the incoming request, and keeps that information in a variety of locations. Laminas\\Diactoros\\ServerRequestFactory::fromGlobals() can simplify marshaling that information into a request instance. You can call the factory method with or without the following arguments, in the following order: $server , typically $_SERVER $query , typically $_GET $body , typically $_POST $cookies , typically $_COOKIE $files , typically $_FILES The method will then return a Laminas\\Diactoros\\ServerRequest instance. If any argument is omitted, the associated superglobal will be used. $request = Laminas\\Diactoros\\ServerRequestFactory::fromGlobals( $_SERVER, $_GET, $_POST, $_COOKIE, $_FILES ); When no cookie array is supplied, fromGlobals will first try to parse the supplied cookie header before falling back to the $_COOKIE superglobal. This is done because PHP has some legacy handling for request parameters which were then registered as global variables. Due to this, cookies with a period in the name were renamed with underlines. By getting the cookies directly from the cookie header, you have access to the original cookies in the way you set them in your application and they are send by the user agent. Manipulating the Response Use the response object to add headers and provide content for the response. Writing to the body does not create a state change in the response, so it can be done without capturing the return value. Manipulating headers does, however. $response = new Laminas\\Diactoros\\Response(); // Write to the response body: $response-&gt;getBody()-&gt;write(\"some content\\n\"); // Multiple calls to write() append: $response-&gt;getBody()-&gt;write(\"more content\\n\"); // now \"some content\\nmore content\\n\" // Add headers // Note: headers do not need to be added before data is written to the body! $response = $response -&gt;withHeader('Content-Type', 'text/plain') -&gt;withAddedHeader('X-Show-Something', 'something'); \"Serving\" an Application Deprecated The class Laminas\\Diactoros\\Server is deprecated as of the 1.8.0 release. We recommend using the class Laminas\\HttpHandlerRunner\\RequestHandlerRunner via the package laminas/laminas-httphandlerrunner instead. Laminas\\Diactoros\\Server mimics a portion of the API of node's http.Server class. It invokes a callback, passing it an ServerRequest , an Response , and optionally a callback to use for incomplete/unhandled requests. You can create a server in one of three ways: // Direct instantiation, with a callback handler, request, and response $server = new Laminas\\Diactoros\\Server( function ($request, $response, $done) { $response-&gt;getBody()-&gt;write(\"Hello world!\"); }, $request, $response ); // Using the createServer factory, providing it with the various superglobals: $server = Laminas\\Diactoros\\Server::createServer( function ($request, $response, $done) { $response-&gt;getBody()-&gt;write(\"Hello world!\"); }, $_SERVER, $_GET, $_POST, $_COOKIE, $_FILES ); // Using the createServerFromRequest factory, and providing it a request: $server = Laminas\\Diactoros\\Server::createServerFromRequest( function ($request, $response, $done) { $response-&gt;getBody()-&gt;write(\"Hello world!\"); }, $request ); Server callbacks can expect up to three arguments, in the following order: $request - the request object $response - the response object $done - an optional callback to call when complete Once you have your server instance, you must instruct it to listen: $server-&gt;listen(); At this time, you can optionally provide a callback to listen() ; this will be passed to the handler as the third argument ( $done ): $server-&gt;listen(function ($request, $response, $error = null) { if (! $error) { return; } // do something with the error... }); Typically, the listen callback will be an error handler, and can expect to receive the request, response, and error as its arguments (though the error may be null).","title":"Usage"},{"location":"v1/usage/#usage","text":"Usage will differ based on whether you are writing an HTTP client, or a server-side application. For HTTP client purposes, you will create and populate a Request instance, and the client should return a Response instance. For server-side applications, you will create a ServerRequest instance, and populate and return a Response instance.","title":"Usage"},{"location":"v1/usage/#http-clients","text":"A client will send a request, and return a response. As a developer, you will create and populate the request, and then introspect the response. Both requests and responses are immutable; if you make changes ‚Äî e.g., by calling setter methods ‚Äî you must capture the return value, as it is a new instance. // Create a request $request = (new Laminas\\Diactoros\\Request()) -&gt;withUri(new Laminas\\Diactoros\\Uri('http://example.com')) -&gt;withMethod('PATCH') -&gt;withAddedHeader('Authorization', 'Bearer ' . $token) -&gt;withAddedHeader('Content-Type', 'application/json'); // OR: $request = new Laminas\\Diactoros\\Request( 'http://example.com', 'PATCH', 'php://memory', [ 'Authorization' =&gt; 'Bearer ' . $token, 'Content-Type' =&gt; 'application/json', ] ); // If you want to set a non-origin-form request target, set the // request-target explicitly: $request = $request-&gt;withRequestTarget((string) $uri); // absolute-form $request = $request-&gt;withRequestTarget($uri-&gt;getAuthority()); // authority-form $request = $request-&gt;withRequestTarget('*'); // asterisk-form // Once you have the instance: $request-&gt;getBody()-&gt;write(json_encode($data)); $response = $client-&gt;send($request); printf(\"Response status: %d (%s)\\n\", $response-&gt;getStatusCode(), $response-&gt;getReasonPhrase()); printf(\"Headers:\\n\"); foreach ($response-&gt;getHeaders() as $header =&gt; $values) { printf(\" %s: %s\\n\", $header, implode(', ', $values)); } printf(\"Message:\\n%s\\n\", $response-&gt;getBody()); (Note: laminas-diactoros does NOT ship with a client implementation; the above is just an illustration of a possible implementation.)","title":"HTTP Clients"},{"location":"v1/usage/#server-side-applications","text":"Server-side applications will need to marshal the incoming request based on superglobals, and will then populate and send a response.","title":"Server-Side Applications"},{"location":"v2/api/","text":"API Request Message Laminas\\Diactoros\\Request implements Psr\\Http\\Message\\RequestInterface , and is intended for client-side requests. It includes the following methods: class Request { public function __construct( $uri = null, $method = null, $body = 'php://memory', array $headers = [] ); // See psr/http-message's RequestInterface for other methods } Requests are immutable. Any methods that would change state ‚Äî those prefixed with with and without ‚Äî all return a new instance with the changes requested. ServerRequest Message For server-side applications, Laminas\\Diactoros\\ServerRequest implements Psr\\Http\\Message\\ServerRequestInterface , which provides access to the elements of an HTTP request, as well as uniform access to the various elements of incoming data. The methods included are: class ServerRequest { public function __construct( array $serverParams = [], array $fileParams = [], $uri = null, $method = null, $body = 'php://input', array $headers = [] ); // See psr/http-message's ServerRequestInterface for other methods. } The ServerRequest is immutable. Any methods that would change state ‚Äî those prefixed with with and without ‚Äî all return a new instance with the changes requested. Server parameters are considered completely immutable, however, as they cannot be recalculated, and, rather, is a source for other values. Response Message Laminas\\Diactoros\\Response provides an implementation of Psr\\Http\\Message\\ResponseInterface , an object to be used to aggregate response information for both HTTP clients and server-side applications, including headers and message body content. It includes the following: class Response { public function __construct( $body = 'php://memory', $statusCode = 200, array $headers = [] ); // See psr/http-message's ResponseInterface for other methods } Like the Request and ServerRequest , responses are immutable. Any methods that would change state ‚Äî those prefixed with with and without ‚Äî all return a new instance with the changes requested. HtmlResponse and JsonResponse The most common use case in server-side applications for generating responses is to provide a string to use for the response, typically HTML or data to serialize as JSON. Laminas\\Diactoros\\Response\\HtmlResponse and Laminas\\Diactoros\\Response\\JsonResponse exist to facilitate these use cases: $htmlResponse = new HtmlResponse($html); $jsonResponse = new JsonResponse($data); In the first example, you will receive a response with a stream containing the HTML; additionally, the Content-Type header will be set to text/html . In the second case, the stream will contain a stream containing the JSON-serialized $data , and have a Content-Type header set to application/json . Both objects allow passing the HTTP status, as well as any headers you want to specify, including the Content-Type header: $htmlResponse = new HtmlResponse($html, 404, [ 'Content-Type' =&gt; [ 'application/xhtml+xml' ], ]); $jsonResponse = new JsonResponse($data, 422, [ 'Content-Type' =&gt; [ 'application/problem+json' ], ]); ServerRequestFactory This static class can be used to marshal a ServerRequest instance from the PHP environment. The primary entry point is Laminas\\Diactoros\\ServerRequestFactory::fromGlobals(array $server, array $query, array $body, array $cookies, array $files, ?Laminas\\Diactoros\\ServerRequestFilter\\FilterServerRequestInterface $requestFilter) . This method will create a new ServerRequest instance with the data provided. Examples of usage are: // Returns new ServerRequest instance, using values from superglobals: $request = ServerRequestFactory::fromGlobals(); // or // Returns new ServerRequest instance, using values provided (in this // case, equivalent to the previous!) $request = ServerRequestFactory::fromGlobals( $_SERVER, $_GET, $_POST, $_COOKIE, $_FILES ); Request Filters Since version 2.11.1, this method takes the additional optional argument $requestFilter . This should be a null value, or an instance of Laminas\\Diactoros\\ServerRequestFilter\\FilterServerRequestInterface . For version 2 releases, if a null is provided, internally the method will assign a Laminas\\Diactoros\\ServerRequestFilter\\FilterUsingXForwardedHeaders instance configured as follows: $requestFilter = $requestFilter ?: FilterUsingXForwardedHeaders::trustReservedSubnets(); The request filter is called on the generated server request instance, and its result is returned from fromGlobals() . For version 3 releases, this method will switch to using a Laminas\\Diactoros\\ServerRequestFilter\\DoNotFilter by default. If you are using this factory method directly, please be aware and update your code accordingly. ServerRequestFactory Helper Functions In order to create the various artifacts required by a ServerRequest instance, Diactoros also provides a number of functions under the Laminas\\Diactoros namespace for introspecting the SAPI $_SERVER parameters, headers, $_FILES , and even the Cookie header. These include: Laminas\\Diactoros\\normalizeServer(array $server, callable $apacheRequestHeaderCallback = null) : array (its main purpose is to aggregate the Authorization header in the SAPI params when under Apache) Laminas\\Diactoros\\marshalProtocolVersionFromSapi(array $server) : string Laminas\\Diactoros\\marshalMethodFromSapi(array $server) : string . Laminas\\Diactoros\\marshalUriFromSapi(array $server, array $headers) : Uri . Please note: this function is deprecated as of version 2.11.1 , and no longer used in ServerRequestFactory::fromGlobals() . Use ServerRequestFactory::fromGlobals() instead. Laminas\\Diactoros\\marshalHeadersFromSapi(array $server) : array Laminas\\Diactoros\\parseCookieHeader(string $header) : array Laminas\\Diactoros\\createUploadedFile(array $spec) : UploadedFile (creates the instance from a normal $_FILES entry) Laminas\\Diactoros\\normalizeUploadedFiles(array $files) : UploadedFileInterface[] (traverses a potentially nested array of uploaded file instances and/or $_FILES entries, including those aggregated under mod_php, php-fpm, and php-cgi in order to create a flat array of UploadedFileInterface instances to use in a request) URI Laminas\\Diactoros\\Uri is an implementation of Psr\\Http\\Message\\UriInterface , and models and validates URIs. It implements __toString() , allowing it to be represented as a string and echo() 'd directly. The following methods are pertinent: class Uri { public function __construct($uri = ''); // See psr/http-message's UriInterface for other methods. } Like the various message objects, URIs are immutable. Any methods that would change state ‚Äî those prefixed with with and without ‚Äî all return a new instance with the changes requested. Stream Laminas\\Diactoros\\Stream is an implementation of Psr\\Http\\Message\\StreamInterface , and provides a number of facilities around manipulating the composed PHP stream resource. The constructor accepts a stream, which may be one of: A stream identifier; e.g., php://input , a filename, etc. A PHP stream resource If a stream identifier is provided, an optional second parameter may be provided, the file mode by which to fopen the stream. ServerRequest objects by default use a php://input stream set to read-only; Response objects by default use a php://memory with a mode of wb+ , allowing binary read/write access. In most cases, you will not interact with the Stream object directly. UploadedFile Laminas\\Diactoros\\UploadedFile is an implementation of Psr\\Http\\Message\\UploadedFileInterface , and provides abstraction around a single uploaded file, including behavior for interacting with it as a stream or moving it to a filesystem location. In most cases, you will only use the methods defined in the UploadedFileInterface .","title":"API"},{"location":"v2/api/#api","text":"","title":"API"},{"location":"v2/api/#request-message","text":"Laminas\\Diactoros\\Request implements Psr\\Http\\Message\\RequestInterface , and is intended for client-side requests. It includes the following methods: class Request { public function __construct( $uri = null, $method = null, $body = 'php://memory', array $headers = [] ); // See psr/http-message's RequestInterface for other methods } Requests are immutable. Any methods that would change state ‚Äî those prefixed with with and without ‚Äî all return a new instance with the changes requested.","title":"Request Message"},{"location":"v2/api/#serverrequest-message","text":"For server-side applications, Laminas\\Diactoros\\ServerRequest implements Psr\\Http\\Message\\ServerRequestInterface , which provides access to the elements of an HTTP request, as well as uniform access to the various elements of incoming data. The methods included are: class ServerRequest { public function __construct( array $serverParams = [], array $fileParams = [], $uri = null, $method = null, $body = 'php://input', array $headers = [] ); // See psr/http-message's ServerRequestInterface for other methods. } The ServerRequest is immutable. Any methods that would change state ‚Äî those prefixed with with and without ‚Äî all return a new instance with the changes requested. Server parameters are considered completely immutable, however, as they cannot be recalculated, and, rather, is a source for other values.","title":"ServerRequest Message"},{"location":"v2/api/#response-message","text":"Laminas\\Diactoros\\Response provides an implementation of Psr\\Http\\Message\\ResponseInterface , an object to be used to aggregate response information for both HTTP clients and server-side applications, including headers and message body content. It includes the following: class Response { public function __construct( $body = 'php://memory', $statusCode = 200, array $headers = [] ); // See psr/http-message's ResponseInterface for other methods } Like the Request and ServerRequest , responses are immutable. Any methods that would change state ‚Äî those prefixed with with and without ‚Äî all return a new instance with the changes requested.","title":"Response Message"},{"location":"v2/api/#serverrequestfactory","text":"This static class can be used to marshal a ServerRequest instance from the PHP environment. The primary entry point is Laminas\\Diactoros\\ServerRequestFactory::fromGlobals(array $server, array $query, array $body, array $cookies, array $files, ?Laminas\\Diactoros\\ServerRequestFilter\\FilterServerRequestInterface $requestFilter) . This method will create a new ServerRequest instance with the data provided. Examples of usage are: // Returns new ServerRequest instance, using values from superglobals: $request = ServerRequestFactory::fromGlobals(); // or // Returns new ServerRequest instance, using values provided (in this // case, equivalent to the previous!) $request = ServerRequestFactory::fromGlobals( $_SERVER, $_GET, $_POST, $_COOKIE, $_FILES );","title":"ServerRequestFactory"},{"location":"v2/api/#uri","text":"Laminas\\Diactoros\\Uri is an implementation of Psr\\Http\\Message\\UriInterface , and models and validates URIs. It implements __toString() , allowing it to be represented as a string and echo() 'd directly. The following methods are pertinent: class Uri { public function __construct($uri = ''); // See psr/http-message's UriInterface for other methods. } Like the various message objects, URIs are immutable. Any methods that would change state ‚Äî those prefixed with with and without ‚Äî all return a new instance with the changes requested.","title":"URI"},{"location":"v2/api/#stream","text":"Laminas\\Diactoros\\Stream is an implementation of Psr\\Http\\Message\\StreamInterface , and provides a number of facilities around manipulating the composed PHP stream resource. The constructor accepts a stream, which may be one of: A stream identifier; e.g., php://input , a filename, etc. A PHP stream resource If a stream identifier is provided, an optional second parameter may be provided, the file mode by which to fopen the stream. ServerRequest objects by default use a php://input stream set to read-only; Response objects by default use a php://memory with a mode of wb+ , allowing binary read/write access. In most cases, you will not interact with the Stream object directly.","title":"Stream"},{"location":"v2/api/#uploadedfile","text":"Laminas\\Diactoros\\UploadedFile is an implementation of Psr\\Http\\Message\\UploadedFileInterface , and provides abstraction around a single uploaded file, including behavior for interacting with it as a stream or moving it to a filesystem location. In most cases, you will only use the methods defined in the UploadedFileInterface .","title":"UploadedFile"},{"location":"v2/custom-responses/","text":"Custom Responses When developing server-side applications, the message type you're most likely to create manually is the response. In such cases, the standard signature can be an obstacle to usability. Let's review: namespace Laminas\\Diactoros; use Psr\\Http\\Message\\ResponseInterface; class Response implements ResponseInterface { public function __construct($body = 'php://temp', $status = 200, array $headers = []); } Some standard use cases, however, make this un-wieldy: Returning a response containing HTML; in this case, you likely want to provide the HTML to the constructor, not a stream with the HTML injected. Returning a response containing JSON; in this case, you likely want to provide the data to serialize to JSON, not a stream containing serialized JSON. Returning a response with no content; in this case, you don't want to bother with the body at all. Returning a redirect response; in this case, you likely just want to specify the target for the Location header, and optionally the status code. Starting with version 1.1, Diactoros offers several custom response types for simplifying these common tasks. Text Responses Laminas\\Diactoros\\Response\\TextResponse creates a plain text response. It sets the Content-Type header to text/plain by default: $response = new Laminas\\Diactoros\\Response\\TextResponse('Hello world!'); The constructor accepts two additional arguments: a status code and an array of headers. $response = new Laminas\\Diactoros\\Response\\TextResponse( $text, 200, ['Content-Type' =&gt; ['text/csv']] ); HTML Responses Laminas\\Diactoros\\Response\\HtmlResponse allows specifying HTML as a payload, and sets the Content-Type header to text/html by default: $response = new Laminas\\Diactoros\\Response\\HtmlResponse($htmlContent); The constructor allows passing two additional arguments: a status code, and an array of headers. These allow you to further seed the initial state of the response, as well as to override the Content-Type header if desired: $response = new Laminas\\Diactoros\\Response\\HtmlResponse( $htmlContent, 200, ['Content-Type' =&gt; ['application/xhtml+xml']] ); Headers must be in the same format as you would provide to the Response constructor . XML Responses Laminas\\Diactoros\\Response\\XmlResponse allows specifying XML as a payload, and sets the Content-Type header to application/xml by default: $response = new Laminas\\Diactoros\\Response\\XmlResponse($xml); The constructor allows passing two additional arguments: a status code, and an array of headers. These allow you to further seed the initial state of the response, as well as to override the Content-Type header if desired: $response = new Laminas\\Diactoros\\Response\\XmlResponse( $xml, 200, ['Content-Type' =&gt; ['application/hal+xml']] ); Headers must be in the same format as you would provide to the Response constructor . JSON Responses Laminas\\Diactoros\\Response\\JsonResponse accepts a data structure to convert to JSON, and sets the Content-Type header to application/json : $response = new Laminas\\Diactoros\\Response\\JsonResponse($data); If providing an object, we recommend implementing JsonSerializable to ensure your object is correctly serialized. Just like the HtmlResponse , the JsonResponse allows passing two additional arguments ‚Äî a status code, and an array of headers ‚Äî to allow you to further seed the initial state of the response: $response = new Laminas\\Diactoros\\Response\\JsonResponse( $data, 200, ['Content-Type' =&gt; ['application/hal+json']] ); Finally, JsonResponse allows a fourth optional argument, the flags to provide to json_encode() . By default, these are set to JSON_HEX_TAG | JSON_HEX_APOS | JSON_HEX_AMP | JSON_HEX_QUOT (integer 15), providing RFC 4627 compliant JSON capable of embedding in HTML. If you want to specify a different set of flags, use the fourth constructor argument: $response = new Laminas\\Diactoros\\Response\\JsonResponse( $data, 200, [], JSON_PRETTY_PRINT | JSON_HEX_TAG | JSON_HEX_APOS | JSON_HEX_AMP | JSON_HEX_QUOT ); Empty Responses Many API actions allow returning empty responses: 201 Created responses are often empty, and only include a Link or Location header pointing to the newly created resource. 202 Accepted responses are typically empty, indicating that the new entity has been received, but not yet processed. 204 No Content responses are, by definition, empty, and often used as a success response when deleting an entity. Laminas\\Diactoros\\Response\\EmptyResponse is a Laminas\\Diactoros\\Response extension that, by default, returns an empty response with a 204 status. Its constructor allows passing the status and headers only: namespace Laminas\\Diactoros\\Response; use Laminas\\Diactoros\\Response; class EmptyResponse extends Response { public function __construct($status = 204, array $headers = []); } An empty, read-only body is injected at instantiation, ensuring no write operations are possible on the response. Usage is typically one of the following forms: use Laminas\\Diactoros\\Response\\EmptyResponse; // Basic 204 response: $response = new EmptyResponse(); // 201 response with location header: $response = new EmptyResponse(201, [ 'Location' =&gt; [ $url ], ]); // Alternately, set the header after instantiation: $response = (new EmptyResponse(201))-&gt;withHeader('Location', $url); Redirects Laminas\\Diactoros\\Response\\RedirectResponse is a Laminas\\Diactoros\\Response extension for producing redirect responses. The only required argument is a URI, which may be provided as either a string or Psr\\Http\\Message\\UriInterface instance. By default, the status 302 is used, and no other headers are produced; you may alter these via the additional optional arguments: namespace Laminas\\Diactoros\\Response; use Laminas\\Diactoros\\Response; class RedirectResponse extends Response { public function __construct($uri, $status = 302, array $headers = []); } Typical usage is: use Laminas\\Diactoros\\Response\\RedirectResponse; // 302 redirect: $response = new RedirectResponse('/user/login'); // 301 redirect: $response = new RedirectResponse('/user/login', 301); // using a URI instance (e.g., by altering the request URI instance) $uri = $request-&gt;getUri(); $response = new RedirectResponse($uri-&gt;withPath('/login')); Creating custom Responses PHP allows constructor overloading. What this means is that constructors of extending classes can define completely different argument sets without conflicting with the parent implementation. Considering that most custom response types do not need to change internal functionality, but instead focus on user experience (i.e., simplifying instantiation), this fact can be leveraged to create your custom types. The general pattern will be something like this: use Laminas\\Diactoros\\Response; class MyCustomResponse extends Response { public function __construct($data, $status = 200, array $headers = []) { // - Do something with $data, and create a Stream for the body (if necessary). // - Maybe set some default headers. parent::__construct($body, $status, $headers); } } Note the call to parent::__construct() . This is particularly relevant, as the implementation at the time of writing has all class properties marked as private, making them inaccessible to extensions; this is done to protect encapsulation and ensure consistency of operations between instances. If you don't want to go the extension route (perhaps you don't want another ResponseInterface implementation within your object graph) you can instead create a factory. As an example: $plainTextResponse = function ($text, $status = 200, array $headers = []) { $response = new Laminas\\Diactoros\\Response('php://temp', $status, $headers); $response-&gt;getBody()-&gt;write($text); if (! $response-&gt;hasHeader('Content-Type')) { $response = $response-&gt;withHeader('Content-Type', 'text/plain'); } return $response; }; $response = $plainTextResponse('Hello, world!'); We recommend following the semantic of providing the status and headers as the final two arguments for any factory or custom response extensions.","title":"Custom Responses"},{"location":"v2/custom-responses/#custom-responses","text":"When developing server-side applications, the message type you're most likely to create manually is the response. In such cases, the standard signature can be an obstacle to usability. Let's review: namespace Laminas\\Diactoros; use Psr\\Http\\Message\\ResponseInterface; class Response implements ResponseInterface { public function __construct($body = 'php://temp', $status = 200, array $headers = []); } Some standard use cases, however, make this un-wieldy: Returning a response containing HTML; in this case, you likely want to provide the HTML to the constructor, not a stream with the HTML injected. Returning a response containing JSON; in this case, you likely want to provide the data to serialize to JSON, not a stream containing serialized JSON. Returning a response with no content; in this case, you don't want to bother with the body at all. Returning a redirect response; in this case, you likely just want to specify the target for the Location header, and optionally the status code. Starting with version 1.1, Diactoros offers several custom response types for simplifying these common tasks.","title":"Custom Responses"},{"location":"v2/custom-responses/#text-responses","text":"Laminas\\Diactoros\\Response\\TextResponse creates a plain text response. It sets the Content-Type header to text/plain by default: $response = new Laminas\\Diactoros\\Response\\TextResponse('Hello world!'); The constructor accepts two additional arguments: a status code and an array of headers. $response = new Laminas\\Diactoros\\Response\\TextResponse( $text, 200, ['Content-Type' =&gt; ['text/csv']] );","title":"Text Responses"},{"location":"v2/custom-responses/#html-responses","text":"Laminas\\Diactoros\\Response\\HtmlResponse allows specifying HTML as a payload, and sets the Content-Type header to text/html by default: $response = new Laminas\\Diactoros\\Response\\HtmlResponse($htmlContent); The constructor allows passing two additional arguments: a status code, and an array of headers. These allow you to further seed the initial state of the response, as well as to override the Content-Type header if desired: $response = new Laminas\\Diactoros\\Response\\HtmlResponse( $htmlContent, 200, ['Content-Type' =&gt; ['application/xhtml+xml']] ); Headers must be in the same format as you would provide to the Response constructor .","title":"HTML Responses"},{"location":"v2/custom-responses/#xml-responses","text":"Laminas\\Diactoros\\Response\\XmlResponse allows specifying XML as a payload, and sets the Content-Type header to application/xml by default: $response = new Laminas\\Diactoros\\Response\\XmlResponse($xml); The constructor allows passing two additional arguments: a status code, and an array of headers. These allow you to further seed the initial state of the response, as well as to override the Content-Type header if desired: $response = new Laminas\\Diactoros\\Response\\XmlResponse( $xml, 200, ['Content-Type' =&gt; ['application/hal+xml']] ); Headers must be in the same format as you would provide to the Response constructor .","title":"XML Responses"},{"location":"v2/custom-responses/#json-responses","text":"Laminas\\Diactoros\\Response\\JsonResponse accepts a data structure to convert to JSON, and sets the Content-Type header to application/json : $response = new Laminas\\Diactoros\\Response\\JsonResponse($data); If providing an object, we recommend implementing JsonSerializable to ensure your object is correctly serialized. Just like the HtmlResponse , the JsonResponse allows passing two additional arguments ‚Äî a status code, and an array of headers ‚Äî to allow you to further seed the initial state of the response: $response = new Laminas\\Diactoros\\Response\\JsonResponse( $data, 200, ['Content-Type' =&gt; ['application/hal+json']] ); Finally, JsonResponse allows a fourth optional argument, the flags to provide to json_encode() . By default, these are set to JSON_HEX_TAG | JSON_HEX_APOS | JSON_HEX_AMP | JSON_HEX_QUOT (integer 15), providing RFC 4627 compliant JSON capable of embedding in HTML. If you want to specify a different set of flags, use the fourth constructor argument: $response = new Laminas\\Diactoros\\Response\\JsonResponse( $data, 200, [], JSON_PRETTY_PRINT | JSON_HEX_TAG | JSON_HEX_APOS | JSON_HEX_AMP | JSON_HEX_QUOT );","title":"JSON Responses"},{"location":"v2/custom-responses/#empty-responses","text":"Many API actions allow returning empty responses: 201 Created responses are often empty, and only include a Link or Location header pointing to the newly created resource. 202 Accepted responses are typically empty, indicating that the new entity has been received, but not yet processed. 204 No Content responses are, by definition, empty, and often used as a success response when deleting an entity. Laminas\\Diactoros\\Response\\EmptyResponse is a Laminas\\Diactoros\\Response extension that, by default, returns an empty response with a 204 status. Its constructor allows passing the status and headers only: namespace Laminas\\Diactoros\\Response; use Laminas\\Diactoros\\Response; class EmptyResponse extends Response { public function __construct($status = 204, array $headers = []); } An empty, read-only body is injected at instantiation, ensuring no write operations are possible on the response. Usage is typically one of the following forms: use Laminas\\Diactoros\\Response\\EmptyResponse; // Basic 204 response: $response = new EmptyResponse(); // 201 response with location header: $response = new EmptyResponse(201, [ 'Location' =&gt; [ $url ], ]); // Alternately, set the header after instantiation: $response = (new EmptyResponse(201))-&gt;withHeader('Location', $url);","title":"Empty Responses"},{"location":"v2/custom-responses/#redirects","text":"Laminas\\Diactoros\\Response\\RedirectResponse is a Laminas\\Diactoros\\Response extension for producing redirect responses. The only required argument is a URI, which may be provided as either a string or Psr\\Http\\Message\\UriInterface instance. By default, the status 302 is used, and no other headers are produced; you may alter these via the additional optional arguments: namespace Laminas\\Diactoros\\Response; use Laminas\\Diactoros\\Response; class RedirectResponse extends Response { public function __construct($uri, $status = 302, array $headers = []); } Typical usage is: use Laminas\\Diactoros\\Response\\RedirectResponse; // 302 redirect: $response = new RedirectResponse('/user/login'); // 301 redirect: $response = new RedirectResponse('/user/login', 301); // using a URI instance (e.g., by altering the request URI instance) $uri = $request-&gt;getUri(); $response = new RedirectResponse($uri-&gt;withPath('/login'));","title":"Redirects"},{"location":"v2/custom-responses/#creating-custom-responses","text":"PHP allows constructor overloading. What this means is that constructors of extending classes can define completely different argument sets without conflicting with the parent implementation. Considering that most custom response types do not need to change internal functionality, but instead focus on user experience (i.e., simplifying instantiation), this fact can be leveraged to create your custom types. The general pattern will be something like this: use Laminas\\Diactoros\\Response; class MyCustomResponse extends Response { public function __construct($data, $status = 200, array $headers = []) { // - Do something with $data, and create a Stream for the body (if necessary). // - Maybe set some default headers. parent::__construct($body, $status, $headers); } } Note the call to parent::__construct() . This is particularly relevant, as the implementation at the time of writing has all class properties marked as private, making them inaccessible to extensions; this is done to protect encapsulation and ensure consistency of operations between instances. If you don't want to go the extension route (perhaps you don't want another ResponseInterface implementation within your object graph) you can instead create a factory. As an example: $plainTextResponse = function ($text, $status = 200, array $headers = []) { $response = new Laminas\\Diactoros\\Response('php://temp', $status, $headers); $response-&gt;getBody()-&gt;write($text); if (! $response-&gt;hasHeader('Content-Type')) { $response = $response-&gt;withHeader('Content-Type', 'text/plain'); } return $response; }; $response = $plainTextResponse('Hello, world!'); We recommend following the semantic of providing the status and headers as the final two arguments for any factory or custom response extensions.","title":"Creating custom Responses"},{"location":"v2/factories/","text":"Factories PSR-17 defines factory interfaces for creating PSR-7 instances. As of version 2.0.0, Diactoros supplies implementations of each as follows: Laminas\\Diactoros\\RequestFactory Laminas\\Diactoros\\ResponseFactory Laminas\\Diactoros\\ServerRequestFactory Laminas\\Diactoros\\StreamFactory Laminas\\Diactoros\\UploadedFileFactory Laminas\\Diactoros\\UriFactory The ServerRequestFactory continues to define the static method fromGlobals() , but also serves as a PSR-17 implementation. These classes may be used as described in the specification document for the purpose of creating Diactoros instances that fulfill PSR-7 typehints. Autoregistration of factories Since 2.3.0 When installing Diactoros in a Laminas or Mezzio application, or any application using the laminas-component-installer plugin , you will now be prompted to install its ConfigProvider and/or Module . When you do, it registers the Diactoros factory implementations under the PSR-17 interface names, allowing you to compose instances of the interface in your application classes..","title":"Factories"},{"location":"v2/factories/#factories","text":"PSR-17 defines factory interfaces for creating PSR-7 instances. As of version 2.0.0, Diactoros supplies implementations of each as follows: Laminas\\Diactoros\\RequestFactory Laminas\\Diactoros\\ResponseFactory Laminas\\Diactoros\\ServerRequestFactory Laminas\\Diactoros\\StreamFactory Laminas\\Diactoros\\UploadedFileFactory Laminas\\Diactoros\\UriFactory The ServerRequestFactory continues to define the static method fromGlobals() , but also serves as a PSR-17 implementation. These classes may be used as described in the specification document for the purpose of creating Diactoros instances that fulfill PSR-7 typehints.","title":"Factories"},{"location":"v2/factories/#autoregistration-of-factories","text":"Since 2.3.0 When installing Diactoros in a Laminas or Mezzio application, or any application using the laminas-component-installer plugin , you will now be prompted to install its ConfigProvider and/or Module . When you do, it registers the Diactoros factory implementations under the PSR-17 interface names, allowing you to compose instances of the interface in your application classes..","title":"Autoregistration of factories"},{"location":"v2/forward-migration/","text":"Preparing for Version 3 ServerRequestFilterInterface defaults Introduced in version 2.11.1, the Laminas\\Diactoros\\ServerRequestFilter\\FilterServerRequestInterface is used by ServerRequestFactory::fromGlobals() to allow modifying the generated ServerRequest instance prior to returning it. The primary use case is to allow modifying the generated URI based on the presence of headers such as X-Forwarded-Host . When operating behind a reverse proxy, the Host header is often rewritten to the name of the node to which the request is being forwarded, and an X-Forwarded-Host header is generated with the original Host value to allow the server to determine the original host the request was intended for. (We have always examined the X-Forwarded-Proto header; as of 2.11.1, we also examine the X-Forwarded-Port header.) To accommodate this use case, we created Laminas\\Diactoros\\ServerRequestFilter\\FilterUsingXForwardedHeaders . Due to potential security issues, it is generally best to only accept these headers if you trust the reverse proxy that has initiated the request. (This value is found in $_SERVER['REMOTE_ADDR'] , which is present as $request-&gt;getServerParams()['REMOTE_ADDR'] within PSR-7 implementations.) FilterUsingXForwardedHeaders provides named constructors to allow you to trust these headers from any source (which has been the default behavior of Diactoros since the beginning), or to specify specific IP addresses or CIDR subnets to trust, along with which headers are trusted. To prevent backwards compatibility breaks, we use this filter by default, marked to trust only proxies on private subnets . Features will be added to the 3.11.0 version of mezzio/mezzio that will allow configuring the Laminas\\Diactoros\\ServerRequestFilter\\FilterServerRequestInterface instance, and we recommend explicitly configuring this to utilize the FilterUsingXForwardedHeaders if you depend on this functionality. If you do not need the functionality, we recommend specifying Laminas\\Diactoros\\ServerRequestFilter\\DoNotFilter as the configured FilterServerRequestInterface in your application immediately. We will update this documentation with a link to the related functionality in mezzio/mezzio when it is published.","title":"Preparing for Version 3"},{"location":"v2/forward-migration/#preparing-for-version-3","text":"","title":"Preparing for Version 3"},{"location":"v2/forward-migration/#serverrequestfilterinterface-defaults","text":"Introduced in version 2.11.1, the Laminas\\Diactoros\\ServerRequestFilter\\FilterServerRequestInterface is used by ServerRequestFactory::fromGlobals() to allow modifying the generated ServerRequest instance prior to returning it. The primary use case is to allow modifying the generated URI based on the presence of headers such as X-Forwarded-Host . When operating behind a reverse proxy, the Host header is often rewritten to the name of the node to which the request is being forwarded, and an X-Forwarded-Host header is generated with the original Host value to allow the server to determine the original host the request was intended for. (We have always examined the X-Forwarded-Proto header; as of 2.11.1, we also examine the X-Forwarded-Port header.) To accommodate this use case, we created Laminas\\Diactoros\\ServerRequestFilter\\FilterUsingXForwardedHeaders . Due to potential security issues, it is generally best to only accept these headers if you trust the reverse proxy that has initiated the request. (This value is found in $_SERVER['REMOTE_ADDR'] , which is present as $request-&gt;getServerParams()['REMOTE_ADDR'] within PSR-7 implementations.) FilterUsingXForwardedHeaders provides named constructors to allow you to trust these headers from any source (which has been the default behavior of Diactoros since the beginning), or to specify specific IP addresses or CIDR subnets to trust, along with which headers are trusted. To prevent backwards compatibility breaks, we use this filter by default, marked to trust only proxies on private subnets . Features will be added to the 3.11.0 version of mezzio/mezzio that will allow configuring the Laminas\\Diactoros\\ServerRequestFilter\\FilterServerRequestInterface instance, and we recommend explicitly configuring this to utilize the FilterUsingXForwardedHeaders if you depend on this functionality. If you do not need the functionality, we recommend specifying Laminas\\Diactoros\\ServerRequestFilter\\DoNotFilter as the configured FilterServerRequestInterface in your application immediately. We will update this documentation with a link to the related functionality in mezzio/mezzio when it is published.","title":"ServerRequestFilterInterface defaults"},{"location":"v2/install/","text":"Installation Install this library using composer: $ composer require laminas/laminas-diactoros laminas-diactoros has the following dependencies (which are managed by Composer): psr/http-message , which defines interfaces for HTTP messages, including requests and responses. laminas-diactoros provides implementations of each of these. psr/http-factory , which defines interfaces for HTTP message factories. laminas-diactoros provides implementations of each of these.","title":"Installation"},{"location":"v2/install/#installation","text":"Install this library using composer: $ composer require laminas/laminas-diactoros laminas-diactoros has the following dependencies (which are managed by Composer): psr/http-message , which defines interfaces for HTTP messages, including requests and responses. laminas-diactoros provides implementations of each of these. psr/http-factory , which defines interfaces for HTTP message factories. laminas-diactoros provides implementations of each of these.","title":"Installation"},{"location":"v2/migration/","text":"Migration to Version 2 If you are only using the PSR-7 implementations (e.g., Request , Response , ServerRequest , etc.), migrating to v2 can be done by updating your laminas/laminas-diactoros constraint in your composer.json . You have two options for doing so: Adopt the v2 release specifically: $ composer require \"laminas/laminas-diactoros:^2.0\" Update your constraint to allow either version: Edit the constraint in your composer.json to read: \"laminas/laminas-diactoros\": \"^1.8.6 || ^2.0\" Update your dependencies: $ composer update The first approach may fail if libraries you depend on specifically require a version 1 release. The second approach may leave you on a version 1 release in situations where other libraries you depend on require version 1. Changed Laminas\\Diactoros\\RequestTrait now raises an InvalidArgumentException in withMethod() for invalid HTTP method values. Laminas\\Diactoros\\Serializer\\Request::toString() no longer raises an UnexpectedValueException due to an unexpected HTTP method; this is due to the fact that the HTTP method value can no longer be set to an invalid value. Laminas\\Diactoros\\marshalHeadersFromSapi() is parsing headers differently compared to the legacy implementation. As a consequence Headers with '0' as values will be part of the parsed Headers. In former versions those headers were ignored. Usages of \\Laminas\\Diactoros\\MessageTrait::hasHeader() and \\Laminas\\Diactoros\\MessageTrait::getHeader() might be affected if you are using ServerRequestFactory::fromGlobals() functionality. Removed Several features were removed for version 2. These include removal of the Emitter functionality, the Server implementation, and a number of methods on the ServerRequestFactory . Emitters Laminas\\Diactoros\\Response\\EmitterInterface and all emitter implementations were removed from laminas-diactoros. They are now available in the laminas/laminas-httphandlerrunner package . In most cases, these can be replaced by changing the namespace of imported classes from Laminas\\Diactoros\\Response to Laminas\\HttpHandlerRunner\\Emitter . Server The Laminas\\Diactoros\\Server class has been removed. We recommend using the RequestHandlerRunner class from laminas/laminas-httphandlerrunner to provide these capabilities instead. Usage is similar, but the RequestHandlerRunner provides better error handling, and integration with emitters. ServerRequestFactory Methods A number of public static methods have been removed from ServerRequestFactory . The following table details the methods removed, and replacements you may use if you still require the functionality. Method Removed Replacement functionality normalizeServer() Laminas\\Diactoros\\normalizeServer() marshalHeaders() Laminas\\Diactoros\\marshalHeadersFromSapi() marshalUriFromServer() Laminas\\Diactoros\\marshalUriFromSapi() marshalRequestUri() Uri::getPath() from the Uri instance returned by marshalUriFromSapi() marshalHostAndPortFromHeaders() Uri::getHost() and Uri::getPort() from the Uri instances returned by marshalUriFromSapi() stripQueryString() explode(\"?\", $path, 2)[0] normalizeFiles() Laminas\\Diactoros\\normalizeUploadedFiles()","title":"Migration to Version 2"},{"location":"v2/migration/#migration-to-version-2","text":"If you are only using the PSR-7 implementations (e.g., Request , Response , ServerRequest , etc.), migrating to v2 can be done by updating your laminas/laminas-diactoros constraint in your composer.json . You have two options for doing so: Adopt the v2 release specifically: $ composer require \"laminas/laminas-diactoros:^2.0\" Update your constraint to allow either version: Edit the constraint in your composer.json to read: \"laminas/laminas-diactoros\": \"^1.8.6 || ^2.0\" Update your dependencies: $ composer update The first approach may fail if libraries you depend on specifically require a version 1 release. The second approach may leave you on a version 1 release in situations where other libraries you depend on require version 1.","title":"Migration to Version 2"},{"location":"v2/migration/#changed","text":"Laminas\\Diactoros\\RequestTrait now raises an InvalidArgumentException in withMethod() for invalid HTTP method values. Laminas\\Diactoros\\Serializer\\Request::toString() no longer raises an UnexpectedValueException due to an unexpected HTTP method; this is due to the fact that the HTTP method value can no longer be set to an invalid value. Laminas\\Diactoros\\marshalHeadersFromSapi() is parsing headers differently compared to the legacy implementation. As a consequence Headers with '0' as values will be part of the parsed Headers. In former versions those headers were ignored. Usages of \\Laminas\\Diactoros\\MessageTrait::hasHeader() and \\Laminas\\Diactoros\\MessageTrait::getHeader() might be affected if you are using ServerRequestFactory::fromGlobals() functionality.","title":"Changed"},{"location":"v2/migration/#removed","text":"Several features were removed for version 2. These include removal of the Emitter functionality, the Server implementation, and a number of methods on the ServerRequestFactory .","title":"Removed"},{"location":"v2/overview/","text":"Overview laminas-diactoros is a PHP package containing implementations of the PSR-7 HTTP message interfaces , as well as the PSR-17 HTTP message factory interfaces .","title":"Overview"},{"location":"v2/overview/#overview","text":"laminas-diactoros is a PHP package containing implementations of the PSR-7 HTTP message interfaces , as well as the PSR-17 HTTP message factory interfaces .","title":"Overview"},{"location":"v2/serialization/","text":"Serialization String At times, it's useful to either create a string representation of a message (serialization), or to cast a string or stream message to an object (deserialization). This package provides features for this in Laminas\\Diactoros\\Request\\Serializer and Laminas\\Diactoros\\Response\\Serializer ; each provides the following static methods: fromString($message) will create either a Request or Response instance (based on the serializer used) from the string message. fromStream(Psr\\Http\\Message\\StreamInterface $stream) will create either a Request or Response instance (based on the serializer used) from the provided stream. toString(Psr\\Http\\Message\\RequestInterface|Psr\\Http\\Message\\ResponseInterface $message) will create either a string from the provided message. The deserialization methods ( from*() ) will raise exceptions if errors occur while parsing the message. The serialization methods ( toString() ) will raise exceptions if required data for serialization is not present in the message instance. Array This package also provides features for array serialization using Laminas\\Diactoros\\Request\\ArraySerializer and Laminas\\Diactoros\\Response\\ArraySerializer ; each provides the following static methods: fromArray(array $message) will create either a Request or Response instance (based on the serializer used) from the array message. toArray(Psr\\Http\\Message\\RequestInterface|Psr\\Http\\Message\\ResponseInterface $message) will create an array from the provided message. The deserialization methods ( fromArray() ) will raise exceptions if errors occur while parsing the message. Example Usage Array serialization can be usesful for log messages: class LoggerMiddleware { /** * @var \\Psr\\Log\\LoggerInterface */ protected $logger; public function __invoke(ServerRequestInterface $request, ResponseInterface $response, callable $next) { $response = $next($request, $response); $this-&gt;logger-&gt;debug('Request/Response', [ 'request' =&gt; \\Laminas\\Diactoros\\Request\\ArraySerializer::toArray($request), 'response' =&gt; \\Laminas\\Diactoros\\Response\\ArraySerializer::toArray($response), ]); return $response; } }","title":"Serialization"},{"location":"v2/serialization/#serialization","text":"","title":"Serialization"},{"location":"v2/serialization/#string","text":"At times, it's useful to either create a string representation of a message (serialization), or to cast a string or stream message to an object (deserialization). This package provides features for this in Laminas\\Diactoros\\Request\\Serializer and Laminas\\Diactoros\\Response\\Serializer ; each provides the following static methods: fromString($message) will create either a Request or Response instance (based on the serializer used) from the string message. fromStream(Psr\\Http\\Message\\StreamInterface $stream) will create either a Request or Response instance (based on the serializer used) from the provided stream. toString(Psr\\Http\\Message\\RequestInterface|Psr\\Http\\Message\\ResponseInterface $message) will create either a string from the provided message. The deserialization methods ( from*() ) will raise exceptions if errors occur while parsing the message. The serialization methods ( toString() ) will raise exceptions if required data for serialization is not present in the message instance.","title":"String"},{"location":"v2/serialization/#array","text":"This package also provides features for array serialization using Laminas\\Diactoros\\Request\\ArraySerializer and Laminas\\Diactoros\\Response\\ArraySerializer ; each provides the following static methods: fromArray(array $message) will create either a Request or Response instance (based on the serializer used) from the array message. toArray(Psr\\Http\\Message\\RequestInterface|Psr\\Http\\Message\\ResponseInterface $message) will create an array from the provided message. The deserialization methods ( fromArray() ) will raise exceptions if errors occur while parsing the message.","title":"Array"},{"location":"v2/server-request-filters/","text":"Server Request Filters New Feature Available since version 2.11.1 Server request filters allow you to modify the initial state of a generated ServerRequest instance as returned from Laminas\\Diactoros\\ServerRequestFactory::fromGlobals() . Common use cases include: Generating and injecting a request ID. Modifying the request URI based on headers provided (e.g., based on the X-Forwarded-Host or X-Forwarded-Proto headers). FilterServerRequestInterface A request filter implements Laminas\\Diactoros\\ServerRequestFilter\\FilterServerRequestInterface : namespace Laminas\\Diactoros\\ServerRequestFilter; use Psr\\Http\\Message\\ServerRequestInterface; interface FilterServerRequestInterface { public function __invoke(ServerRequestInterface $request): ServerRequestInterface; } Implementations We provide the following implementations: DoNotFilter : returns the provided $request verbatim. FilterUsingXForwardedHeaders : if the originating request comes from a trusted proxy, examines the X-Forwarded-* headers, and returns the request instance with a URI instance that reflects those headers. DoNotFilter This filter returns the $request argument back verbatim when invoked. FilterUsingXForwardedHeaders Servers behind a reverse proxy need mechanisms to determine the original URL requested. As such, reverse proxies have provided a number of mechanisms for delivering this information, with the use of X-Forwarded-* headers being the most prevalant. These include: X-Forwarded-Host : the original Host header value. X-Forwarded-Port : the original port included in the Host header value. X-Forwarded-Proto : the original URI scheme used to make the request (e.g., \"http\" or \"https\"). Laminas\\Diactoros\\ServerRequestFilter\\FilterUsingXForwardedHeaders provides named constructors for choosing whether to never trust proxies, always trust proxies, or choose wich proxies and/or headers to trust in order to modify the URI composed in the request instance to match the original request. These named constructors are: FilterUsingXForwardedHeadersFactory::trustProxies(string[] $proxyCIDRList, string[] $trustedHeaders = FilterUsingXForwardedHeaders::X_FORWARDED_HEADERS): void : when this method is called, only requests originating from the trusted proxy/ies will be considered, as well as only the headers specified. Proxies may be specified by IP address, or using CIDR notation for subnets; both IPv4 and IPv6 are accepted. The special string \"*\" will be translated to two entries, 0.0.0.0/0 and ::/0 . FilterUsingXForwardedHeaders::trustAny(): void : when this method is called, the filter will trust requests from any origin, and use any of the above headers to modify the URI instance. It is functionally equivalent to FilterUsingXForwardedHeaders::trustProxies(['*']) . FilterUsingXForwardedHeaders::trustReservedSubnets(): void : when this method is called, the filter will trust requests made from reserved, private subnets. It is functionally equivalent to FilterUsingXForwardedHeaders::trustProxies() with the following elements in the $proxyCIDRList : 10.0.0.0/8 127.0.0.0/8 172.16.0.0/12 192.168.0.0/16 ::1/128 (IPv6 localhost) fc00::/7 (IPv6 private networks) fe80::/10 (IPv6 local-link addresses) Internally, the filter checks the REMOTE_ADDR server parameter (as retrieved from getServerParams() ) and compares it against each proxy listed; the first to match indicates trust. Constants The FilterUsingXForwardedHeaders defines the following constants for use in specifying various headers: HEADER_HOST : corresponds to X-Forwarded-Host . HEADER_PORT : corresponds to X-Forwarded-Port . HEADER_PROTO : corresponds to X-Forwarded-Proto . Example usage Trusting all X-Forwarded-* headers from any source: $filter = FilterUsingXForwardedHeaders::trustAny(); Trusting only the X-Forwarded-Host header from any source: $filter = FilterUsingXForwardedHeaders::trustProxies('0.0.0.0/0', [FilterUsingXForwardedHeaders::HEADER_HOST]); Trusting the X-Forwarded-Host and X-Forwarded-Proto headers from a single Class C subnet: $filter = FilterUsingXForwardedHeaders::trustProxies( '192.168.1.0/24', [FilterUsingXForwardedHeaders::HEADER_HOST, FilterUsingXForwardedHeaders::HEADER_PROTO] ); Trusting the X-Forwarded-Host header from either a Class A or a Class C subnet: $filter = FilterUsingXForwardedHeaders::trustProxies( ['10.1.1.0/16', '192.168.1.0/24'], [FilterUsingXForwardedHeaders::HEADER_HOST, FilterUsingXForwardedHeaders::HEADER_PROTO] ); Trusting any X-Forwarded-* header from any private subnet: $filter = FilterUsingXForwardedHeaders::trustReservedSubnets();","title":"Server Request Filters"},{"location":"v2/server-request-filters/#server-request-filters","text":"New Feature Available since version 2.11.1 Server request filters allow you to modify the initial state of a generated ServerRequest instance as returned from Laminas\\Diactoros\\ServerRequestFactory::fromGlobals() . Common use cases include: Generating and injecting a request ID. Modifying the request URI based on headers provided (e.g., based on the X-Forwarded-Host or X-Forwarded-Proto headers).","title":"Server Request Filters"},{"location":"v2/server-request-filters/#filterserverrequestinterface","text":"A request filter implements Laminas\\Diactoros\\ServerRequestFilter\\FilterServerRequestInterface : namespace Laminas\\Diactoros\\ServerRequestFilter; use Psr\\Http\\Message\\ServerRequestInterface; interface FilterServerRequestInterface { public function __invoke(ServerRequestInterface $request): ServerRequestInterface; }","title":"FilterServerRequestInterface"},{"location":"v2/server-request-filters/#implementations","text":"We provide the following implementations: DoNotFilter : returns the provided $request verbatim. FilterUsingXForwardedHeaders : if the originating request comes from a trusted proxy, examines the X-Forwarded-* headers, and returns the request instance with a URI instance that reflects those headers.","title":"Implementations"},{"location":"v2/usage/","text":"Usage Usage will differ based on whether you are writing an HTTP client, or a server-side application. For HTTP client purposes, you will create and populate a Request instance, and the client should return a Response instance. For server-side applications, you will create a ServerRequest instance, and populate and return a Response instance. HTTP Clients A client will send a request, and return a response. As a developer, you will create and populate the request, and then introspect the response. Both requests and responses are immutable; if you make changes ‚Äî e.g., by calling setter methods ‚Äî you must capture the return value, as it is a new instance. // Create a request $request = (new Laminas\\Diactoros\\Request()) -&gt;withUri(new Laminas\\Diactoros\\Uri('http://example.com')) -&gt;withMethod('PATCH') -&gt;withAddedHeader('Authorization', 'Bearer ' . $token) -&gt;withAddedHeader('Content-Type', 'application/json'); // OR: $request = new Laminas\\Diactoros\\Request( 'http://example.com', 'PATCH', 'php://memory', [ 'Authorization' =&gt; 'Bearer ' . $token, 'Content-Type' =&gt; 'application/json', ] ); // If you want to set a non-origin-form request target, set the // request-target explicitly: $request = $request-&gt;withRequestTarget((string) $uri); // absolute-form $request = $request-&gt;withRequestTarget($uri-&gt;getAuthority()); // authority-form $request = $request-&gt;withRequestTarget('*'); // asterisk-form // Once you have the instance: $request-&gt;getBody()-&gt;write(json_encode($data)); $response = $client-&gt;send($request); printf(\"Response status: %d (%s)\\n\", $response-&gt;getStatusCode(), $response-&gt;getReasonPhrase()); printf(\"Headers:\\n\"); foreach ($response-&gt;getHeaders() as $header =&gt; $values) { printf(\" %s: %s\\n\", $header, implode(', ', $values)); } printf(\"Message:\\n%s\\n\", $response-&gt;getBody()); (Note: laminas-diactoros does NOT ship with a client implementation; the above is just an illustration of a possible implementation.) Server-Side Applications Server-side applications will need to marshal the incoming request based on superglobals, and will then populate and send a response. Marshaling an incoming Request PHP contains a plethora of information about the incoming request, and keeps that information in a variety of locations. Laminas\\Diactoros\\ServerRequestFactory::fromGlobals() can simplify marshaling that information into a request instance. You can call the factory method with or without the following arguments, in the following order: $server , typically $_SERVER $query , typically $_GET $body , typically $_POST $cookies , typically $_COOKIE $files , typically $_FILES The method will then return a Laminas\\Diactoros\\ServerRequest instance. If any argument is omitted, the associated superglobal will be used. $request = Laminas\\Diactoros\\ServerRequestFactory::fromGlobals( $_SERVER, $_GET, $_POST, $_COOKIE, $_FILES ); When no cookie array is supplied, fromGlobals will first try to parse the supplied cookie header before falling back to the $_COOKIE superglobal. This is done because PHP has some legacy handling for request parameters which were then registered as global variables. Due to this, cookies with a period in the name were renamed with underlines. By getting the cookies directly from the cookie header, you have access to the original cookies in the way you set them in your application and they are send by the user agent. Strict Content- header matching Available since version 2.6.0 By default, Diactoros will resolve any $_SERVER keys matching the prefix CONTENT_ as HTTP headers. However, the proper behavior is to only match CONTENT_TYPE , CONTENT_LENGTH , and CONTENT_MD5 , mapping them to Content-Type , Content-Length , and Content-MD5 headers, respectively. Since changing the existing behavior may break some applications, we will not make the functionality more restrictive before version 3.0.0. If you are running into issues whereby you have ENV variables that are being munged into request headers, you can define the following ENV variable in your application to enable the more strict behavior: LAMINAS_DIACTOROS_STRICT_CONTENT_HEADER_LOOKUP As an example, you could define it in your application's .env file if you are using vlucas/phpdotenv : LAMINAS_DIACTOROS_STRICT_CONTENT_HEADER_LOOKUP=true Alternately, you could define it as a php-fpm or Apache environment variable. Once this ENV variable is present, the logic for identifying Content-* headers will only look at the CONTENT_TYPE , CONTENT_LENGTH , and CONTENT_MD5 variables in $_SERVER , and skip over any others. Manipulating the Response Use the response object to add headers and provide content for the response. Writing to the body does not create a state change in the response, so it can be done without capturing the return value. Manipulating headers does, however. $response = new Laminas\\Diactoros\\Response(); // Write to the response body: $response-&gt;getBody()-&gt;write(\"some content\\n\"); // Multiple calls to write() append: $response-&gt;getBody()-&gt;write(\"more content\\n\"); // now \"some content\\nmore content\\n\" // Add headers // Note: headers do not need to be added before data is written to the body! $response = $response -&gt;withHeader('Content-Type', 'text/plain') -&gt;withAddedHeader('X-Show-Something', 'something');","title":"Usage"},{"location":"v2/usage/#usage","text":"Usage will differ based on whether you are writing an HTTP client, or a server-side application. For HTTP client purposes, you will create and populate a Request instance, and the client should return a Response instance. For server-side applications, you will create a ServerRequest instance, and populate and return a Response instance.","title":"Usage"},{"location":"v2/usage/#http-clients","text":"A client will send a request, and return a response. As a developer, you will create and populate the request, and then introspect the response. Both requests and responses are immutable; if you make changes ‚Äî e.g., by calling setter methods ‚Äî you must capture the return value, as it is a new instance. // Create a request $request = (new Laminas\\Diactoros\\Request()) -&gt;withUri(new Laminas\\Diactoros\\Uri('http://example.com')) -&gt;withMethod('PATCH') -&gt;withAddedHeader('Authorization', 'Bearer ' . $token) -&gt;withAddedHeader('Content-Type', 'application/json'); // OR: $request = new Laminas\\Diactoros\\Request( 'http://example.com', 'PATCH', 'php://memory', [ 'Authorization' =&gt; 'Bearer ' . $token, 'Content-Type' =&gt; 'application/json', ] ); // If you want to set a non-origin-form request target, set the // request-target explicitly: $request = $request-&gt;withRequestTarget((string) $uri); // absolute-form $request = $request-&gt;withRequestTarget($uri-&gt;getAuthority()); // authority-form $request = $request-&gt;withRequestTarget('*'); // asterisk-form // Once you have the instance: $request-&gt;getBody()-&gt;write(json_encode($data)); $response = $client-&gt;send($request); printf(\"Response status: %d (%s)\\n\", $response-&gt;getStatusCode(), $response-&gt;getReasonPhrase()); printf(\"Headers:\\n\"); foreach ($response-&gt;getHeaders() as $header =&gt; $values) { printf(\" %s: %s\\n\", $header, implode(', ', $values)); } printf(\"Message:\\n%s\\n\", $response-&gt;getBody()); (Note: laminas-diactoros does NOT ship with a client implementation; the above is just an illustration of a possible implementation.)","title":"HTTP Clients"},{"location":"v2/usage/#server-side-applications","text":"Server-side applications will need to marshal the incoming request based on superglobals, and will then populate and send a response.","title":"Server-Side Applications"},{"location":"v3/api/","text":"API Request Message Laminas\\Diactoros\\Request implements Psr\\Http\\Message\\RequestInterface , and is intended for client-side requests. It includes the following methods: class Request { public function __construct( $uri = null, $method = null, $body = 'php://memory', array $headers = [] ); // See psr/http-message's RequestInterface for other methods } Requests are immutable. Any methods that would change state ‚Äî those prefixed with with and without ‚Äî all return a new instance with the changes requested. ServerRequest Message For server-side applications, Laminas\\Diactoros\\ServerRequest implements Psr\\Http\\Message\\ServerRequestInterface , which provides access to the elements of an HTTP request, as well as uniform access to the various elements of incoming data. The methods included are: class ServerRequest { public function __construct( array $serverParams = [], array $fileParams = [], $uri = null, $method = null, $body = 'php://input', array $headers = [] ); // See psr/http-message's ServerRequestInterface for other methods. } The ServerRequest is immutable. Any methods that would change state ‚Äî those prefixed with with and without ‚Äî all return a new instance with the changes requested. Server parameters are considered completely immutable, however, as they cannot be recalculated, and, rather, is a source for other values. Response Message Laminas\\Diactoros\\Response provides an implementation of Psr\\Http\\Message\\ResponseInterface , an object to be used to aggregate response information for both HTTP clients and server-side applications, including headers and message body content. It includes the following: class Response { public function __construct( $body = 'php://memory', $statusCode = 200, array $headers = [] ); // See psr/http-message's ResponseInterface for other methods } Like the Request and ServerRequest , responses are immutable. Any methods that would change state ‚Äî those prefixed with with and without ‚Äî all return a new instance with the changes requested. HtmlResponse and JsonResponse The most common use case in server-side applications for generating responses is to provide a string to use for the response, typically HTML or data to serialize as JSON. Laminas\\Diactoros\\Response\\HtmlResponse and Laminas\\Diactoros\\Response\\JsonResponse exist to facilitate these use cases: $htmlResponse = new HtmlResponse($html); $jsonResponse = new JsonResponse($data); In the first example, you will receive a response with a stream containing the HTML; additionally, the Content-Type header will be set to text/html . In the second case, the stream will contain a stream containing the JSON-serialized $data , and have a Content-Type header set to application/json . Both objects allow passing the HTTP status, as well as any headers you want to specify, including the Content-Type header: $htmlResponse = new HtmlResponse($html, 404, [ 'Content-Type' =&gt; [ 'application/xhtml+xml' ], ]); $jsonResponse = new JsonResponse($data, 422, [ 'Content-Type' =&gt; [ 'application/problem+json' ], ]); ServerRequestFactory This static class can be used to marshal a ServerRequest instance from the PHP environment. The primary entry point is Laminas\\Diactoros\\ServerRequestFactory::fromGlobals(array $server, array $query, array $body, array $cookies, array $files, ?Laminas\\Diactoros\\ServerRequestFilter\\FilterServerRequestInterface $requestFilter) . This method will create a new ServerRequest instance with the data provided. Examples of usage are: // Returns new ServerRequest instance, using values from superglobals: $request = ServerRequestFactory::fromGlobals(); // or // Returns new ServerRequest instance, using values provided (in this // case, equivalent to the previous!) $request = ServerRequestFactory::fromGlobals( $_SERVER, $_GET, $_POST, $_COOKIE, $_FILES ); Request Filters Since version 2.11.1, this method takes the additional optional argument $requestFilter . This should be a null value, or an instance of Laminas\\Diactoros\\ServerRequestFilter\\FilterServerRequestInterface . For version 2 releases, if a null is provided, internally the method will assign a Laminas\\Diactoros\\ServerRequestFilter\\FilterUsingXForwardedHeaders instance configured as follows: $requestFilter = $requestFilter ?: FilterUsingXForwardedHeaders::trustReservedSubnets(); The request filter is called on the generated server request instance, and its result is returned from fromGlobals() . For version 3 releases, this method will switch to using a Laminas\\Diactoros\\ServerRequestFilter\\DoNotFilter by default. If you are using this factory method directly, please be aware and update your code accordingly. ServerRequestFactory Helper Functions In order to create the various artifacts required by a ServerRequest instance, Diactoros also provides a number of functions under the Laminas\\Diactoros namespace for introspecting the SAPI $_SERVER parameters, headers, $_FILES , and even the Cookie header. These include: Laminas\\Diactoros\\normalizeServer(array $server, callable $apacheRequestHeaderCallback = null) : array (its main purpose is to aggregate the Authorization header in the SAPI params when under Apache) Laminas\\Diactoros\\marshalProtocolVersionFromSapi(array $server) : string Laminas\\Diactoros\\marshalMethodFromSapi(array $server) : string . Laminas\\Diactoros\\marshalHeadersFromSapi(array $server) : array Laminas\\Diactoros\\parseCookieHeader(string $header) : array Laminas\\Diactoros\\createUploadedFile(array $spec) : UploadedFile (creates the instance from a normal $_FILES entry) Laminas\\Diactoros\\normalizeUploadedFiles(array $files) : UploadedFileInterface[] (traverses a potentially nested array of uploaded file instances and/or $_FILES entries, including those aggregated under mod_php, php-fpm, and php-cgi in order to create a flat array of UploadedFileInterface instances to use in a request) URI Laminas\\Diactoros\\Uri is an implementation of Psr\\Http\\Message\\UriInterface , and models and validates URIs. It implements __toString() , allowing it to be represented as a string and echo() 'd directly. The following methods are pertinent: class Uri { public function __construct($uri = ''); // See psr/http-message's UriInterface for other methods. } Like the various message objects, URIs are immutable. Any methods that would change state ‚Äî those prefixed with with and without ‚Äî all return a new instance with the changes requested. Stream Laminas\\Diactoros\\Stream is an implementation of Psr\\Http\\Message\\StreamInterface , and provides a number of facilities around manipulating the composed PHP stream resource. The constructor accepts a stream, which may be one of: A stream identifier; e.g., php://input , a filename, etc. A PHP stream resource; or If a stream identifier is provided, an optional second parameter may be provided, the file mode by which to fopen the stream. ServerRequest objects by default use a php://input stream set to read-only; Response objects by default use a php://memory with a mode of wb+ , allowing binary read/write access. In most cases, you will not interact with the Stream object directly. UploadedFile Laminas\\Diactoros\\UploadedFile is an implementation of Psr\\Http\\Message\\UploadedFileInterface , and provides abstraction around a single uploaded file, including behavior for interacting with it as a stream or moving it to a filesystem location. In most cases, you will only use the methods defined in the UploadedFileInterface .","title":"API"},{"location":"v3/api/#api","text":"","title":"API"},{"location":"v3/api/#request-message","text":"Laminas\\Diactoros\\Request implements Psr\\Http\\Message\\RequestInterface , and is intended for client-side requests. It includes the following methods: class Request { public function __construct( $uri = null, $method = null, $body = 'php://memory', array $headers = [] ); // See psr/http-message's RequestInterface for other methods } Requests are immutable. Any methods that would change state ‚Äî those prefixed with with and without ‚Äî all return a new instance with the changes requested.","title":"Request Message"},{"location":"v3/api/#serverrequest-message","text":"For server-side applications, Laminas\\Diactoros\\ServerRequest implements Psr\\Http\\Message\\ServerRequestInterface , which provides access to the elements of an HTTP request, as well as uniform access to the various elements of incoming data. The methods included are: class ServerRequest { public function __construct( array $serverParams = [], array $fileParams = [], $uri = null, $method = null, $body = 'php://input', array $headers = [] ); // See psr/http-message's ServerRequestInterface for other methods. } The ServerRequest is immutable. Any methods that would change state ‚Äî those prefixed with with and without ‚Äî all return a new instance with the changes requested. Server parameters are considered completely immutable, however, as they cannot be recalculated, and, rather, is a source for other values.","title":"ServerRequest Message"},{"location":"v3/api/#response-message","text":"Laminas\\Diactoros\\Response provides an implementation of Psr\\Http\\Message\\ResponseInterface , an object to be used to aggregate response information for both HTTP clients and server-side applications, including headers and message body content. It includes the following: class Response { public function __construct( $body = 'php://memory', $statusCode = 200, array $headers = [] ); // See psr/http-message's ResponseInterface for other methods } Like the Request and ServerRequest , responses are immutable. Any methods that would change state ‚Äî those prefixed with with and without ‚Äî all return a new instance with the changes requested.","title":"Response Message"},{"location":"v3/api/#serverrequestfactory","text":"This static class can be used to marshal a ServerRequest instance from the PHP environment. The primary entry point is Laminas\\Diactoros\\ServerRequestFactory::fromGlobals(array $server, array $query, array $body, array $cookies, array $files, ?Laminas\\Diactoros\\ServerRequestFilter\\FilterServerRequestInterface $requestFilter) . This method will create a new ServerRequest instance with the data provided. Examples of usage are: // Returns new ServerRequest instance, using values from superglobals: $request = ServerRequestFactory::fromGlobals(); // or // Returns new ServerRequest instance, using values provided (in this // case, equivalent to the previous!) $request = ServerRequestFactory::fromGlobals( $_SERVER, $_GET, $_POST, $_COOKIE, $_FILES );","title":"ServerRequestFactory"},{"location":"v3/api/#uri","text":"Laminas\\Diactoros\\Uri is an implementation of Psr\\Http\\Message\\UriInterface , and models and validates URIs. It implements __toString() , allowing it to be represented as a string and echo() 'd directly. The following methods are pertinent: class Uri { public function __construct($uri = ''); // See psr/http-message's UriInterface for other methods. } Like the various message objects, URIs are immutable. Any methods that would change state ‚Äî those prefixed with with and without ‚Äî all return a new instance with the changes requested.","title":"URI"},{"location":"v3/api/#stream","text":"Laminas\\Diactoros\\Stream is an implementation of Psr\\Http\\Message\\StreamInterface , and provides a number of facilities around manipulating the composed PHP stream resource. The constructor accepts a stream, which may be one of: A stream identifier; e.g., php://input , a filename, etc. A PHP stream resource; or If a stream identifier is provided, an optional second parameter may be provided, the file mode by which to fopen the stream. ServerRequest objects by default use a php://input stream set to read-only; Response objects by default use a php://memory with a mode of wb+ , allowing binary read/write access. In most cases, you will not interact with the Stream object directly.","title":"Stream"},{"location":"v3/api/#uploadedfile","text":"Laminas\\Diactoros\\UploadedFile is an implementation of Psr\\Http\\Message\\UploadedFileInterface , and provides abstraction around a single uploaded file, including behavior for interacting with it as a stream or moving it to a filesystem location. In most cases, you will only use the methods defined in the UploadedFileInterface .","title":"UploadedFile"},{"location":"v3/custom-responses/","text":"Custom Responses When developing server-side applications, the message type you're most likely to create manually is the response. In such cases, the standard signature can be an obstacle to usability. Let's review: namespace Laminas\\Diactoros; use Psr\\Http\\Message\\ResponseInterface; class Response implements ResponseInterface { public function __construct($body = 'php://temp', $status = 200, array $headers = []); } Some standard use cases, however, make this un-wieldy: Returning a response containing HTML; in this case, you likely want to provide the HTML to the constructor, not a stream with the HTML injected. Returning a response containing JSON; in this case, you likely want to provide the data to serialize to JSON, not a stream containing serialized JSON. Returning a response with no content; in this case, you don't want to bother with the body at all. Returning a redirect response; in this case, you likely just want to specify the target for the Location header, and optionally the status code. Starting with version 1.1, Diactoros offers several custom response types for simplifying these common tasks. Text Responses Laminas\\Diactoros\\Response\\TextResponse creates a plain text response. It sets the Content-Type header to text/plain by default: $response = new Laminas\\Diactoros\\Response\\TextResponse('Hello world!'); The constructor accepts two additional arguments: a status code and an array of headers. $response = new Laminas\\Diactoros\\Response\\TextResponse( $text, 200, ['Content-Type' =&gt; ['text/csv']] ); HTML Responses Laminas\\Diactoros\\Response\\HtmlResponse allows specifying HTML as a payload, and sets the Content-Type header to text/html by default: $response = new Laminas\\Diactoros\\Response\\HtmlResponse($htmlContent); The constructor allows passing two additional arguments: a status code, and an array of headers. These allow you to further seed the initial state of the response, as well as to override the Content-Type header if desired: $response = new Laminas\\Diactoros\\Response\\HtmlResponse( $htmlContent, 200, ['Content-Type' =&gt; ['application/xhtml+xml']] ); Headers must be in the same format as you would provide to the Response constructor . XML Responses Laminas\\Diactoros\\Response\\XmlResponse allows specifying XML as a payload, and sets the Content-Type header to application/xml by default: $response = new Laminas\\Diactoros\\Response\\XmlResponse($xml); The constructor allows passing two additional arguments: a status code, and an array of headers. These allow you to further seed the initial state of the response, as well as to override the Content-Type header if desired: $response = new Laminas\\Diactoros\\Response\\XmlResponse( $xml, 200, ['Content-Type' =&gt; ['application/hal+xml']] ); Headers must be in the same format as you would provide to the Response constructor . JSON Responses Laminas\\Diactoros\\Response\\JsonResponse accepts a data structure to convert to JSON, and sets the Content-Type header to application/json : $response = new Laminas\\Diactoros\\Response\\JsonResponse($data); If providing an object, we recommend implementing JsonSerializable to ensure your object is correctly serialized. Just like the HtmlResponse , the JsonResponse allows passing two additional arguments ‚Äî a status code, and an array of headers ‚Äî to allow you to further seed the initial state of the response: $response = new Laminas\\Diactoros\\Response\\JsonResponse( $data, 200, ['Content-Type' =&gt; ['application/hal+json']] ); Finally, JsonResponse allows a fourth optional argument, the flags to provide to json_encode() . By default, these are set to JSON_HEX_TAG | JSON_HEX_APOS | JSON_HEX_AMP | JSON_HEX_QUOT (integer 15), providing RFC 4627 compliant JSON capable of embedding in HTML. If you want to specify a different set of flags, use the fourth constructor argument: $response = new Laminas\\Diactoros\\Response\\JsonResponse( $data, 200, [], JSON_PRETTY_PRINT | JSON_HEX_TAG | JSON_HEX_APOS | JSON_HEX_AMP | JSON_HEX_QUOT ); Empty Responses Many API actions allow returning empty responses: 201 Created responses are often empty, and only include a Link or Location header pointing to the newly created resource. 202 Accepted responses are typically empty, indicating that the new entity has been received, but not yet processed. 204 No Content responses are, by definition, empty, and often used as a success response when deleting an entity. Laminas\\Diactoros\\Response\\EmptyResponse is a Laminas\\Diactoros\\Response extension that, by default, returns an empty response with a 204 status. Its constructor allows passing the status and headers only: namespace Laminas\\Diactoros\\Response; use Laminas\\Diactoros\\Response; class EmptyResponse extends Response { public function __construct($status = 204, array $headers = []); } An empty, read-only body is injected at instantiation, ensuring no write operations are possible on the response. Usage is typically one of the following forms: use Laminas\\Diactoros\\Response\\EmptyResponse; // Basic 204 response: $response = new EmptyResponse(); // 201 response with location header: $response = new EmptyResponse(201, [ 'Location' =&gt; [ $url ], ]); // Alternately, set the header after instantiation: $response = (new EmptyResponse(201))-&gt;withHeader('Location', $url); Redirects Laminas\\Diactoros\\Response\\RedirectResponse is a Laminas\\Diactoros\\Response extension for producing redirect responses. The only required argument is a URI, which may be provided as either a string or Psr\\Http\\Message\\UriInterface instance. By default, the status 302 is used, and no other headers are produced; you may alter these via the additional optional arguments: namespace Laminas\\Diactoros\\Response; use Laminas\\Diactoros\\Response; class RedirectResponse extends Response { public function __construct($uri, $status = 302, array $headers = []); } Typical usage is: use Laminas\\Diactoros\\Response\\RedirectResponse; // 302 redirect: $response = new RedirectResponse('/user/login'); // 301 redirect: $response = new RedirectResponse('/user/login', 301); // using a URI instance (e.g., by altering the request URI instance) $uri = $request-&gt;getUri(); $response = new RedirectResponse($uri-&gt;withPath('/login')); Creating custom Responses PHP allows constructor overloading. What this means is that constructors of extending classes can define completely different argument sets without conflicting with the parent implementation. Considering that most custom response types do not need to change internal functionality, but instead focus on user experience (i.e., simplifying instantiation), this fact can be leveraged to create your custom types. The general pattern will be something like this: use Laminas\\Diactoros\\Response; class MyCustomResponse extends Response { public function __construct($data, $status = 200, array $headers = []) { // - Do something with $data, and create a Stream for the body (if necessary). // - Maybe set some default headers. parent::__construct($body, $status, $headers); } } Note the call to parent::__construct() . This is particularly relevant, as the implementation at the time of writing has all class properties marked as private, making them inaccessible to extensions; this is done to protect encapsulation and ensure consistency of operations between instances. If you don't want to go the extension route (perhaps you don't want another ResponseInterface implementation within your object graph) you can instead create a factory. As an example: $plainTextResponse = function ($text, $status = 200, array $headers = []) { $response = new Laminas\\Diactoros\\Response('php://temp', $status, $headers); $response-&gt;getBody()-&gt;write($text); if (! $response-&gt;hasHeader('Content-Type')) { $response = $response-&gt;withHeader('Content-Type', 'text/plain'); } return $response; }; $response = $plainTextResponse('Hello, world!'); We recommend following the semantic of providing the status and headers as the final two arguments for any factory or custom response extensions.","title":"Custom Responses"},{"location":"v3/custom-responses/#custom-responses","text":"When developing server-side applications, the message type you're most likely to create manually is the response. In such cases, the standard signature can be an obstacle to usability. Let's review: namespace Laminas\\Diactoros; use Psr\\Http\\Message\\ResponseInterface; class Response implements ResponseInterface { public function __construct($body = 'php://temp', $status = 200, array $headers = []); } Some standard use cases, however, make this un-wieldy: Returning a response containing HTML; in this case, you likely want to provide the HTML to the constructor, not a stream with the HTML injected. Returning a response containing JSON; in this case, you likely want to provide the data to serialize to JSON, not a stream containing serialized JSON. Returning a response with no content; in this case, you don't want to bother with the body at all. Returning a redirect response; in this case, you likely just want to specify the target for the Location header, and optionally the status code. Starting with version 1.1, Diactoros offers several custom response types for simplifying these common tasks.","title":"Custom Responses"},{"location":"v3/custom-responses/#text-responses","text":"Laminas\\Diactoros\\Response\\TextResponse creates a plain text response. It sets the Content-Type header to text/plain by default: $response = new Laminas\\Diactoros\\Response\\TextResponse('Hello world!'); The constructor accepts two additional arguments: a status code and an array of headers. $response = new Laminas\\Diactoros\\Response\\TextResponse( $text, 200, ['Content-Type' =&gt; ['text/csv']] );","title":"Text Responses"},{"location":"v3/custom-responses/#html-responses","text":"Laminas\\Diactoros\\Response\\HtmlResponse allows specifying HTML as a payload, and sets the Content-Type header to text/html by default: $response = new Laminas\\Diactoros\\Response\\HtmlResponse($htmlContent); The constructor allows passing two additional arguments: a status code, and an array of headers. These allow you to further seed the initial state of the response, as well as to override the Content-Type header if desired: $response = new Laminas\\Diactoros\\Response\\HtmlResponse( $htmlContent, 200, ['Content-Type' =&gt; ['application/xhtml+xml']] ); Headers must be in the same format as you would provide to the Response constructor .","title":"HTML Responses"},{"location":"v3/custom-responses/#xml-responses","text":"Laminas\\Diactoros\\Response\\XmlResponse allows specifying XML as a payload, and sets the Content-Type header to application/xml by default: $response = new Laminas\\Diactoros\\Response\\XmlResponse($xml); The constructor allows passing two additional arguments: a status code, and an array of headers. These allow you to further seed the initial state of the response, as well as to override the Content-Type header if desired: $response = new Laminas\\Diactoros\\Response\\XmlResponse( $xml, 200, ['Content-Type' =&gt; ['application/hal+xml']] ); Headers must be in the same format as you would provide to the Response constructor .","title":"XML Responses"},{"location":"v3/custom-responses/#json-responses","text":"Laminas\\Diactoros\\Response\\JsonResponse accepts a data structure to convert to JSON, and sets the Content-Type header to application/json : $response = new Laminas\\Diactoros\\Response\\JsonResponse($data); If providing an object, we recommend implementing JsonSerializable to ensure your object is correctly serialized. Just like the HtmlResponse , the JsonResponse allows passing two additional arguments ‚Äî a status code, and an array of headers ‚Äî to allow you to further seed the initial state of the response: $response = new Laminas\\Diactoros\\Response\\JsonResponse( $data, 200, ['Content-Type' =&gt; ['application/hal+json']] ); Finally, JsonResponse allows a fourth optional argument, the flags to provide to json_encode() . By default, these are set to JSON_HEX_TAG | JSON_HEX_APOS | JSON_HEX_AMP | JSON_HEX_QUOT (integer 15), providing RFC 4627 compliant JSON capable of embedding in HTML. If you want to specify a different set of flags, use the fourth constructor argument: $response = new Laminas\\Diactoros\\Response\\JsonResponse( $data, 200, [], JSON_PRETTY_PRINT | JSON_HEX_TAG | JSON_HEX_APOS | JSON_HEX_AMP | JSON_HEX_QUOT );","title":"JSON Responses"},{"location":"v3/custom-responses/#empty-responses","text":"Many API actions allow returning empty responses: 201 Created responses are often empty, and only include a Link or Location header pointing to the newly created resource. 202 Accepted responses are typically empty, indicating that the new entity has been received, but not yet processed. 204 No Content responses are, by definition, empty, and often used as a success response when deleting an entity. Laminas\\Diactoros\\Response\\EmptyResponse is a Laminas\\Diactoros\\Response extension that, by default, returns an empty response with a 204 status. Its constructor allows passing the status and headers only: namespace Laminas\\Diactoros\\Response; use Laminas\\Diactoros\\Response; class EmptyResponse extends Response { public function __construct($status = 204, array $headers = []); } An empty, read-only body is injected at instantiation, ensuring no write operations are possible on the response. Usage is typically one of the following forms: use Laminas\\Diactoros\\Response\\EmptyResponse; // Basic 204 response: $response = new EmptyResponse(); // 201 response with location header: $response = new EmptyResponse(201, [ 'Location' =&gt; [ $url ], ]); // Alternately, set the header after instantiation: $response = (new EmptyResponse(201))-&gt;withHeader('Location', $url);","title":"Empty Responses"},{"location":"v3/custom-responses/#redirects","text":"Laminas\\Diactoros\\Response\\RedirectResponse is a Laminas\\Diactoros\\Response extension for producing redirect responses. The only required argument is a URI, which may be provided as either a string or Psr\\Http\\Message\\UriInterface instance. By default, the status 302 is used, and no other headers are produced; you may alter these via the additional optional arguments: namespace Laminas\\Diactoros\\Response; use Laminas\\Diactoros\\Response; class RedirectResponse extends Response { public function __construct($uri, $status = 302, array $headers = []); } Typical usage is: use Laminas\\Diactoros\\Response\\RedirectResponse; // 302 redirect: $response = new RedirectResponse('/user/login'); // 301 redirect: $response = new RedirectResponse('/user/login', 301); // using a URI instance (e.g., by altering the request URI instance) $uri = $request-&gt;getUri(); $response = new RedirectResponse($uri-&gt;withPath('/login'));","title":"Redirects"},{"location":"v3/custom-responses/#creating-custom-responses","text":"PHP allows constructor overloading. What this means is that constructors of extending classes can define completely different argument sets without conflicting with the parent implementation. Considering that most custom response types do not need to change internal functionality, but instead focus on user experience (i.e., simplifying instantiation), this fact can be leveraged to create your custom types. The general pattern will be something like this: use Laminas\\Diactoros\\Response; class MyCustomResponse extends Response { public function __construct($data, $status = 200, array $headers = []) { // - Do something with $data, and create a Stream for the body (if necessary). // - Maybe set some default headers. parent::__construct($body, $status, $headers); } } Note the call to parent::__construct() . This is particularly relevant, as the implementation at the time of writing has all class properties marked as private, making them inaccessible to extensions; this is done to protect encapsulation and ensure consistency of operations between instances. If you don't want to go the extension route (perhaps you don't want another ResponseInterface implementation within your object graph) you can instead create a factory. As an example: $plainTextResponse = function ($text, $status = 200, array $headers = []) { $response = new Laminas\\Diactoros\\Response('php://temp', $status, $headers); $response-&gt;getBody()-&gt;write($text); if (! $response-&gt;hasHeader('Content-Type')) { $response = $response-&gt;withHeader('Content-Type', 'text/plain'); } return $response; }; $response = $plainTextResponse('Hello, world!'); We recommend following the semantic of providing the status and headers as the final two arguments for any factory or custom response extensions.","title":"Creating custom Responses"},{"location":"v3/factories/","text":"Factories PSR-17 defines factory interfaces for creating PSR-7 instances. As of version 2.0.0, Diactoros supplies implementations of each as follows: Laminas\\Diactoros\\RequestFactory Laminas\\Diactoros\\ResponseFactory Laminas\\Diactoros\\ServerRequestFactory Laminas\\Diactoros\\StreamFactory Laminas\\Diactoros\\UploadedFileFactory Laminas\\Diactoros\\UriFactory The ServerRequestFactory continues to define the static method fromGlobals() , but also serves as a PSR-17 implementation. These classes may be used as described in the specification document for the purpose of creating Diactoros instances that fulfill PSR-7 typehints. Autoregistration of factories Since 2.3.0 When installing Diactoros in a Laminas or Mezzio application, or any application using the laminas-component-installer plugin , you will now be prompted to install its ConfigProvider and/or Module . When you do, it registers the Diactoros factory implementations under the PSR-17 interface names, allowing you to compose instances of the interface in your application classes..","title":"Factories"},{"location":"v3/factories/#factories","text":"PSR-17 defines factory interfaces for creating PSR-7 instances. As of version 2.0.0, Diactoros supplies implementations of each as follows: Laminas\\Diactoros\\RequestFactory Laminas\\Diactoros\\ResponseFactory Laminas\\Diactoros\\ServerRequestFactory Laminas\\Diactoros\\StreamFactory Laminas\\Diactoros\\UploadedFileFactory Laminas\\Diactoros\\UriFactory The ServerRequestFactory continues to define the static method fromGlobals() , but also serves as a PSR-17 implementation. These classes may be used as described in the specification document for the purpose of creating Diactoros instances that fulfill PSR-7 typehints.","title":"Factories"},{"location":"v3/factories/#autoregistration-of-factories","text":"Since 2.3.0 When installing Diactoros in a Laminas or Mezzio application, or any application using the laminas-component-installer plugin , you will now be prompted to install its ConfigProvider and/or Module . When you do, it registers the Diactoros factory implementations under the PSR-17 interface names, allowing you to compose instances of the interface in your application classes..","title":"Autoregistration of factories"},{"location":"v3/install/","text":"Installation Install this library using composer: $ composer require laminas/laminas-diactoros laminas-diactoros has the following dependencies (which are managed by Composer): psr/http-message , which defines interfaces for HTTP messages, including requests and responses. laminas-diactoros provides implementations of each of these. psr/http-factory , which defines interfaces for HTTP message factories. laminas-diactoros provides implementations of each of these.","title":"Installation"},{"location":"v3/install/#installation","text":"Install this library using composer: $ composer require laminas/laminas-diactoros laminas-diactoros has the following dependencies (which are managed by Composer): psr/http-message , which defines interfaces for HTTP messages, including requests and responses. laminas-diactoros provides implementations of each of these. psr/http-factory , which defines interfaces for HTTP message factories. laminas-diactoros provides implementations of each of these.","title":"Installation"},{"location":"v3/migration/","text":"Migration to Version 3 Changed The following features were changed in version 3. PSR-7 v2 support This version adds support for PSR-7 version 2. Diactoros 2.25.0 added support for PSR-7 version 1.1, and at that time, already had return type declarations that would mostly fulfill PSR-7 version 2. However, there were two locations in PSR-7 where void returns were added: StreamInterface::seek() UploadedFileInterface::moveTo() Since absence of a return type declaration implies mixed in PHP, switching to void is always considered a BC break, as it reduces the allowed behavior. As such, any consumers extending our Stream or UploadedFile classes and overriding either of these methods would experience a BC breaking change due to types. For consumers, usage should be completely backwards compatible, however. ServerRequestFactory::fromGlobals The factory Laminas\\Diactoros\\ServerRequestFactory::fromGlobals() was modified such that passing empty array values for arguments that accept null or an array now will not use the associated superglobal in that scenario. Previously, an empty array value was treated as identical to null , and would cause the factory to fallback to superglobals; now, this is a way to provide an empty set for the associated value(s). marshalHeadersFromSapi The function Laminas\\Diactoros\\marshalHeadersFromSapi() , which is consumed by Laminas\\Diactoros\\ServerRequestFactory::fromGlobals() , was modified such that it will now filter out header field names that evaluate to integers. Please see the Security Features document for more details. Removed The following features were removed for version 3. GdImage support in Stream Laminas\\Diactoros\\Stream \"supported\" usage of resources created via the GD extension. However, this support was unstable, and largely did not work. With the update in PHP 8.0 to usage of opaque resource types for all GD resources, it did not work at all. As such, we have removed the feature entirely. If you need to stream an image, the recommendation is to use the functionality in the GD extension to write the image to a temporary file (e.g., php://temp ), and then to pass that to Laminas\\Diactoros\\Stream . marshalUriFromSapi function The Laminas\\Diactoros\\marshalUriFromSapi() function was deprecated starting in version 2.11.0, and now removed. The functionality that was present in it was moved to Laminas\\Diactoros\\UriFactory::createFromSapi() . If you were using the function previously, use this static method instead. PhpInputStream The class Laminas\\Diactoros\\PhpInputStream was originally developed prior to PHP 5.6, when php://input was read-once . As such, we needed to handle it specially to ensure it could be read multiple times. Since 5.6 and onwards, the stream is seekable and can be re-used. With version 3, we have removed it, and modified our ServerRequest such that it now uses a read-only Stream referencing php://input as its stream resource. If you were using the class directly, you can instead use new Laminas\\Diactoros\\Stream('php://input', 'r') to achieve the same result.","title":"Migration to Version 3"},{"location":"v3/migration/#migration-to-version-3","text":"","title":"Migration to Version 3"},{"location":"v3/migration/#changed","text":"The following features were changed in version 3.","title":"Changed"},{"location":"v3/migration/#removed","text":"The following features were removed for version 3.","title":"Removed"},{"location":"v3/overview/","text":"Overview laminas-diactoros is a PHP package containing implementations of the PSR-7 HTTP message interfaces , as well as the PSR-17 HTTP message factory interfaces .","title":"Overview"},{"location":"v3/overview/#overview","text":"laminas-diactoros is a PHP package containing implementations of the PSR-7 HTTP message interfaces , as well as the PSR-17 HTTP message factory interfaces .","title":"Overview"},{"location":"v3/security/","text":"Security Features ServerRequestFilterInterface defaults Laminas\\Diactoros\\ServerRequestFilter\\FilterServerRequestInterface is used by ServerRequestFactory::fromGlobals() to allow modifying the generated ServerRequest instance prior to returning it. The primary use case is to allow modifying the generated URI based on the presence of headers such as X-Forwarded-Host . When operating behind a reverse proxy, the Host header is often rewritten to the name of the node to which the request is being forwarded, and an X-Forwarded-Host header is generated with the original Host value to allow the server to determine the original host the request was intended for. We also similarly examine the X-Forwarded-Port header. To accommodate this use case, we provide Laminas\\Diactoros\\ServerRequestFilter\\FilterUsingXForwardedHeaders . Due to potential security issues, it is generally best to only accept these headers if you trust the reverse proxy that has initiated the request. (This value is found in $_SERVER['REMOTE_ADDR'] , which is present as $request-&gt;getServerParams()['REMOTE_ADDR'] within PSR-7 implementations.) FilterUsingXForwardedHeaders provides named constructors to allow you to trust these headers from any source (which has been the default behavior of Diactoros since the beginning), or to specify specific IP addresses or CIDR subnets to trust, along with which headers are trusted. We use this filter by default, marked to trust only proxies on private subnets . If you do not need the functionality, we recommend specifying Laminas\\Diactoros\\ServerRequestFilter\\DoNotFilter as the configured FilterServerRequestInterface in your application. Filtering of integer header names PSR-7 targets RFC 7230 . RFC-7230 defines an ABNF pattern for header field names that allows the possibility of using an integer as a header field; e.g., 1234: header value The PSR-7, Psr\\Http\\MessageInterface::getHeaders() method requires implementations to return an associative array, where the key is the header field name. This triggers an interesting quirk in PHP: when adding a value to an array using a string that consists of an integer value, PHP will convert this value to an integer (see PHP bug 80309 for more details). This presents several issues: First, it means that consumers cannot depend on the header field name returned being a string. Second, our own validation of header field name will fail, as it will not see a string. Normally, this will not present an issue, as the way to add headers to a message is via the MessageInterface::withHeader() and MessageInterface::withAddedHeader() methods, which both require a string name argument. However, when using Laminas\\Diactoros\\ServerRequestFactory::fromGlobals() , it can present a problem if any discovered headers have field names that evaluate to integers. To prevent issues, as of version 3.0.0, the ServerRequestFactory implementation in Diactoros filters out any headers that evaluate to integers. If you wish to accept these anyways, we strongly recommend that you modify your web server to rewrite the incoming header field name to add a prefix or suffix string (e.g., X-Digit-1 , 1-Digit ). Integer keys can still be returned from getHeaders() While withHeader() and withHeaderLine() require string name values, please be aware that these can be presented as string integers. These names will be considered valid, and that means that when you call getHeaders() , any such names will become integers at this time.","title":"Security Features"},{"location":"v3/security/#security-features","text":"","title":"Security Features"},{"location":"v3/security/#serverrequestfilterinterface-defaults","text":"Laminas\\Diactoros\\ServerRequestFilter\\FilterServerRequestInterface is used by ServerRequestFactory::fromGlobals() to allow modifying the generated ServerRequest instance prior to returning it. The primary use case is to allow modifying the generated URI based on the presence of headers such as X-Forwarded-Host . When operating behind a reverse proxy, the Host header is often rewritten to the name of the node to which the request is being forwarded, and an X-Forwarded-Host header is generated with the original Host value to allow the server to determine the original host the request was intended for. We also similarly examine the X-Forwarded-Port header. To accommodate this use case, we provide Laminas\\Diactoros\\ServerRequestFilter\\FilterUsingXForwardedHeaders . Due to potential security issues, it is generally best to only accept these headers if you trust the reverse proxy that has initiated the request. (This value is found in $_SERVER['REMOTE_ADDR'] , which is present as $request-&gt;getServerParams()['REMOTE_ADDR'] within PSR-7 implementations.) FilterUsingXForwardedHeaders provides named constructors to allow you to trust these headers from any source (which has been the default behavior of Diactoros since the beginning), or to specify specific IP addresses or CIDR subnets to trust, along with which headers are trusted. We use this filter by default, marked to trust only proxies on private subnets . If you do not need the functionality, we recommend specifying Laminas\\Diactoros\\ServerRequestFilter\\DoNotFilter as the configured FilterServerRequestInterface in your application.","title":"ServerRequestFilterInterface defaults"},{"location":"v3/security/#filtering-of-integer-header-names","text":"PSR-7 targets RFC 7230 . RFC-7230 defines an ABNF pattern for header field names that allows the possibility of using an integer as a header field; e.g., 1234: header value The PSR-7, Psr\\Http\\MessageInterface::getHeaders() method requires implementations to return an associative array, where the key is the header field name. This triggers an interesting quirk in PHP: when adding a value to an array using a string that consists of an integer value, PHP will convert this value to an integer (see PHP bug 80309 for more details). This presents several issues: First, it means that consumers cannot depend on the header field name returned being a string. Second, our own validation of header field name will fail, as it will not see a string. Normally, this will not present an issue, as the way to add headers to a message is via the MessageInterface::withHeader() and MessageInterface::withAddedHeader() methods, which both require a string name argument. However, when using Laminas\\Diactoros\\ServerRequestFactory::fromGlobals() , it can present a problem if any discovered headers have field names that evaluate to integers. To prevent issues, as of version 3.0.0, the ServerRequestFactory implementation in Diactoros filters out any headers that evaluate to integers. If you wish to accept these anyways, we strongly recommend that you modify your web server to rewrite the incoming header field name to add a prefix or suffix string (e.g., X-Digit-1 , 1-Digit ). Integer keys can still be returned from getHeaders() While withHeader() and withHeaderLine() require string name values, please be aware that these can be presented as string integers. These names will be considered valid, and that means that when you call getHeaders() , any such names will become integers at this time.","title":"Filtering of integer header names"},{"location":"v3/serialization/","text":"Serialization String At times, it's useful to either create a string representation of a message (serialization), or to cast a string or stream message to an object (deserialization). This package provides features for this in Laminas\\Diactoros\\Request\\Serializer and Laminas\\Diactoros\\Response\\Serializer ; each provides the following static methods: fromString($message) will create either a Request or Response instance (based on the serializer used) from the string message. fromStream(Psr\\Http\\Message\\StreamInterface $stream) will create either a Request or Response instance (based on the serializer used) from the provided stream. toString(Psr\\Http\\Message\\RequestInterface|Psr\\Http\\Message\\ResponseInterface $message) will create either a string from the provided message. The deserialization methods ( from*() ) will raise exceptions if errors occur while parsing the message. The serialization methods ( toString() ) will raise exceptions if required data for serialization is not present in the message instance. Array This package also provides features for array serialization using Laminas\\Diactoros\\Request\\ArraySerializer and Laminas\\Diactoros\\Response\\ArraySerializer ; each provides the following static methods: fromArray(array $message) will create either a Request or Response instance (based on the serializer used) from the array message. toArray(Psr\\Http\\Message\\RequestInterface|Psr\\Http\\Message\\ResponseInterface $message) will create an array from the provided message. The deserialization methods ( fromArray() ) will raise exceptions if errors occur while parsing the message. Example Usage Array serialization can be usesful for log messages: class LoggerMiddleware { /** * @var \\Psr\\Log\\LoggerInterface */ protected $logger; public function __invoke(ServerRequestInterface $request, ResponseInterface $response, callable $next) { $response = $next($request, $response); $this-&gt;logger-&gt;debug('Request/Response', [ 'request' =&gt; \\Laminas\\Diactoros\\Request\\ArraySerializer::toArray($request), 'response' =&gt; \\Laminas\\Diactoros\\Response\\ArraySerializer::toArray($response), ]); return $response; } }","title":"Serialization"},{"location":"v3/serialization/#serialization","text":"","title":"Serialization"},{"location":"v3/serialization/#string","text":"At times, it's useful to either create a string representation of a message (serialization), or to cast a string or stream message to an object (deserialization). This package provides features for this in Laminas\\Diactoros\\Request\\Serializer and Laminas\\Diactoros\\Response\\Serializer ; each provides the following static methods: fromString($message) will create either a Request or Response instance (based on the serializer used) from the string message. fromStream(Psr\\Http\\Message\\StreamInterface $stream) will create either a Request or Response instance (based on the serializer used) from the provided stream. toString(Psr\\Http\\Message\\RequestInterface|Psr\\Http\\Message\\ResponseInterface $message) will create either a string from the provided message. The deserialization methods ( from*() ) will raise exceptions if errors occur while parsing the message. The serialization methods ( toString() ) will raise exceptions if required data for serialization is not present in the message instance.","title":"String"},{"location":"v3/serialization/#array","text":"This package also provides features for array serialization using Laminas\\Diactoros\\Request\\ArraySerializer and Laminas\\Diactoros\\Response\\ArraySerializer ; each provides the following static methods: fromArray(array $message) will create either a Request or Response instance (based on the serializer used) from the array message. toArray(Psr\\Http\\Message\\RequestInterface|Psr\\Http\\Message\\ResponseInterface $message) will create an array from the provided message. The deserialization methods ( fromArray() ) will raise exceptions if errors occur while parsing the message.","title":"Array"},{"location":"v3/server-request-filters/","text":"Server Request Filters New Feature Available since version 2.11.1 Server request filters allow you to modify the initial state of a generated ServerRequest instance as returned from Laminas\\Diactoros\\ServerRequestFactory::fromGlobals() . Common use cases include: Generating and injecting a request ID. Modifying the request URI based on headers provided (e.g., based on the X-Forwarded-Host or X-Forwarded-Proto headers). FilterServerRequestInterface A request filter implements Laminas\\Diactoros\\ServerRequestFilter\\FilterServerRequestInterface : namespace Laminas\\Diactoros\\ServerRequestFilter; use Psr\\Http\\Message\\ServerRequestInterface; interface FilterServerRequestInterface { public function __invoke(ServerRequestInterface $request): ServerRequestInterface; } Implementations We provide the following implementations: DoNotFilter : returns the provided $request verbatim. FilterUsingXForwardedHeaders : if the originating request comes from a trusted proxy, examines the X-Forwarded-* headers, and returns the request instance with a URI instance that reflects those headers. DoNotFilter This filter returns the $request argument back verbatim when invoked. FilterUsingXForwardedHeaders Servers behind a reverse proxy need mechanisms to determine the original URL requested. As such, reverse proxies have provided a number of mechanisms for delivering this information, with the use of X-Forwarded-* headers being the most prevalant. These include: X-Forwarded-Host : the original Host header value. X-Forwarded-Port : the original port included in the Host header value. X-Forwarded-Proto : the original URI scheme used to make the request (e.g., \"http\" or \"https\"). Laminas\\Diactoros\\ServerRequestFilter\\FilterUsingXForwardedHeaders provides named constructors for choosing whether to never trust proxies, always trust proxies, or choose wich proxies and/or headers to trust in order to modify the URI composed in the request instance to match the original request. These named constructors are: FilterUsingXForwardedHeadersFactory::trustProxies(string[] $proxyCIDRList, string[] $trustedHeaders = FilterUsingXForwardedHeaders::X_FORWARDED_HEADERS): void : when this method is called, only requests originating from the trusted proxy/ies will be considered, as well as only the headers specified. Proxies may be specified by IP address, or using CIDR notation for subnets; both IPv4 and IPv6 are accepted. The special string \"*\" will be translated to two entries, 0.0.0.0/0 and ::/0 . FilterUsingXForwardedHeaders::trustAny(): void : when this method is called, the filter will trust requests from any origin, and use any of the above headers to modify the URI instance. It is functionally equivalent to FilterUsingXForwardedHeaders::trustProxies(['*']) . FilterUsingXForwardedHeaders::trustReservedSubnets(): void : when this method is called, the filter will trust requests made from reserved, private subnets. It is functionally equivalent to FilterUsingXForwardedHeaders::trustProxies() with the following elements in the $proxyCIDRList : 10.0.0.0/8 127.0.0.0/8 172.16.0.0/12 192.168.0.0/16 ::1/128 (IPv6 localhost) fc00::/7 (IPv6 private networks) fe80::/10 (IPv6 local-link addresses) Internally, the filter checks the REMOTE_ADDR server parameter (as retrieved from getServerParams() ) and compares it against each proxy listed; the first to match indicates trust. Constants The FilterUsingXForwardedHeaders defines the following constants for use in specifying various headers: HEADER_HOST : corresponds to X-Forwarded-Host . HEADER_PORT : corresponds to X-Forwarded-Port . HEADER_PROTO : corresponds to X-Forwarded-Proto . Example usage Trusting all X-Forwarded-* headers from any source: $filter = FilterUsingXForwardedHeaders::trustAny(); Trusting only the X-Forwarded-Host header from any source: $filter = FilterUsingXForwardedHeaders::trustProxies('0.0.0.0/0', [FilterUsingXForwardedHeaders::HEADER_HOST]); Trusting the X-Forwarded-Host and X-Forwarded-Proto headers from a single Class C subnet: $filter = FilterUsingXForwardedHeaders::trustProxies( '192.168.1.0/24', [FilterUsingXForwardedHeaders::HEADER_HOST, FilterUsingXForwardedHeaders::HEADER_PROTO] ); Trusting the X-Forwarded-Host header from either a Class A or a Class C subnet: $filter = FilterUsingXForwardedHeaders::trustProxies( ['10.1.1.0/16', '192.168.1.0/24'], [FilterUsingXForwardedHeaders::HEADER_HOST, FilterUsingXForwardedHeaders::HEADER_PROTO] ); Trusting any X-Forwarded-* header from any private subnet: $filter = FilterUsingXForwardedHeaders::trustReservedSubnets();","title":"Server Request Filters"},{"location":"v3/server-request-filters/#server-request-filters","text":"New Feature Available since version 2.11.1 Server request filters allow you to modify the initial state of a generated ServerRequest instance as returned from Laminas\\Diactoros\\ServerRequestFactory::fromGlobals() . Common use cases include: Generating and injecting a request ID. Modifying the request URI based on headers provided (e.g., based on the X-Forwarded-Host or X-Forwarded-Proto headers).","title":"Server Request Filters"},{"location":"v3/server-request-filters/#filterserverrequestinterface","text":"A request filter implements Laminas\\Diactoros\\ServerRequestFilter\\FilterServerRequestInterface : namespace Laminas\\Diactoros\\ServerRequestFilter; use Psr\\Http\\Message\\ServerRequestInterface; interface FilterServerRequestInterface { public function __invoke(ServerRequestInterface $request): ServerRequestInterface; }","title":"FilterServerRequestInterface"},{"location":"v3/server-request-filters/#implementations","text":"We provide the following implementations: DoNotFilter : returns the provided $request verbatim. FilterUsingXForwardedHeaders : if the originating request comes from a trusted proxy, examines the X-Forwarded-* headers, and returns the request instance with a URI instance that reflects those headers.","title":"Implementations"},{"location":"v3/usage/","text":"Usage Usage will differ based on whether you are writing an HTTP client, or a server-side application. For HTTP client purposes, you will create and populate a Request instance, and the client should return a Response instance. For server-side applications, you will create a ServerRequest instance, and populate and return a Response instance. HTTP Clients A client will send a request, and return a response. As a developer, you will create and populate the request, and then introspect the response. Both requests and responses are immutable; if you make changes ‚Äî e.g., by calling setter methods ‚Äî you must capture the return value, as it is a new instance. // Create a request $request = (new Laminas\\Diactoros\\Request()) -&gt;withUri(new Laminas\\Diactoros\\Uri('http://example.com')) -&gt;withMethod('PATCH') -&gt;withAddedHeader('Authorization', 'Bearer ' . $token) -&gt;withAddedHeader('Content-Type', 'application/json'); // OR: $request = new Laminas\\Diactoros\\Request( 'http://example.com', 'PATCH', 'php://memory', [ 'Authorization' =&gt; 'Bearer ' . $token, 'Content-Type' =&gt; 'application/json', ] ); // If you want to set a non-origin-form request target, set the // request-target explicitly: $request = $request-&gt;withRequestTarget((string) $uri); // absolute-form $request = $request-&gt;withRequestTarget($uri-&gt;getAuthority()); // authority-form $request = $request-&gt;withRequestTarget('*'); // asterisk-form // Once you have the instance: $request-&gt;getBody()-&gt;write(json_encode($data)); $response = $client-&gt;send($request); printf(\"Response status: %d (%s)\\n\", $response-&gt;getStatusCode(), $response-&gt;getReasonPhrase()); printf(\"Headers:\\n\"); foreach ($response-&gt;getHeaders() as $header =&gt; $values) { printf(\" %s: %s\\n\", $header, implode(', ', $values)); } printf(\"Message:\\n%s\\n\", $response-&gt;getBody()); (Note: laminas-diactoros does NOT ship with a client implementation; the above is just an illustration of a possible implementation.) Server-Side Applications Server-side applications will need to marshal the incoming request based on superglobals, and will then populate and send a response. Marshaling an incoming Request PHP contains a plethora of information about the incoming request, and keeps that information in a variety of locations. Laminas\\Diactoros\\ServerRequestFactory::fromGlobals() can simplify marshaling that information into a request instance. You can call the factory method with or without the following arguments, in the following order: $server , typically $_SERVER $query , typically $_GET $body , typically $_POST $cookies , typically $_COOKIE $files , typically $_FILES The method will then return a Laminas\\Diactoros\\ServerRequest instance. If any argument is omitted, the associated superglobal will be used. $request = Laminas\\Diactoros\\ServerRequestFactory::fromGlobals( $_SERVER, $_GET, $_POST, $_COOKIE, $_FILES ); When no cookie array is supplied, fromGlobals will first try to parse the supplied cookie header before falling back to the $_COOKIE superglobal. This is done because PHP has some legacy handling for request parameters which were then registered as global variables. Due to this, cookies with a period in the name were renamed with underlines. By getting the cookies directly from the cookie header, you have access to the original cookies in the way you set them in your application and they are send by the user agent. Strict Content- header matching Available since version 2.6.0 By default, Diactoros will resolve any $_SERVER keys matching the prefix CONTENT_ as HTTP headers. However, the proper behavior is to only match CONTENT_TYPE , CONTENT_LENGTH , and CONTENT_MD5 , mapping them to Content-Type , Content-Length , and Content-MD5 headers, respectively. Since changing the existing behavior may break some applications, we will not make the functionality more restrictive before version 3.0.0. If you are running into issues whereby you have ENV variables that are being munged into request headers, you can define the following ENV variable in your application to enable the more strict behavior: LAMINAS_DIACTOROS_STRICT_CONTENT_HEADER_LOOKUP As an example, you could define it in your application's .env file if you are using vlucas/phpdotenv : LAMINAS_DIACTOROS_STRICT_CONTENT_HEADER_LOOKUP=true Alternately, you could define it as a php-fpm or Apache environment variable. Once this ENV variable is present, the logic for identifying Content-* headers will only look at the CONTENT_TYPE , CONTENT_LENGTH , and CONTENT_MD5 variables in $_SERVER , and skip over any others. Manipulating the Response Use the response object to add headers and provide content for the response. Writing to the body does not create a state change in the response, so it can be done without capturing the return value. Manipulating headers does, however. $response = new Laminas\\Diactoros\\Response(); // Write to the response body: $response-&gt;getBody()-&gt;write(\"some content\\n\"); // Multiple calls to write() append: $response-&gt;getBody()-&gt;write(\"more content\\n\"); // now \"some content\\nmore content\\n\" // Add headers // Note: headers do not need to be added before data is written to the body! $response = $response -&gt;withHeader('Content-Type', 'text/plain') -&gt;withAddedHeader('X-Show-Something', 'something');","title":"Usage"},{"location":"v3/usage/#usage","text":"Usage will differ based on whether you are writing an HTTP client, or a server-side application. For HTTP client purposes, you will create and populate a Request instance, and the client should return a Response instance. For server-side applications, you will create a ServerRequest instance, and populate and return a Response instance.","title":"Usage"},{"location":"v3/usage/#http-clients","text":"A client will send a request, and return a response. As a developer, you will create and populate the request, and then introspect the response. Both requests and responses are immutable; if you make changes ‚Äî e.g., by calling setter methods ‚Äî you must capture the return value, as it is a new instance. // Create a request $request = (new Laminas\\Diactoros\\Request()) -&gt;withUri(new Laminas\\Diactoros\\Uri('http://example.com')) -&gt;withMethod('PATCH') -&gt;withAddedHeader('Authorization', 'Bearer ' . $token) -&gt;withAddedHeader('Content-Type', 'application/json'); // OR: $request = new Laminas\\Diactoros\\Request( 'http://example.com', 'PATCH', 'php://memory', [ 'Authorization' =&gt; 'Bearer ' . $token, 'Content-Type' =&gt; 'application/json', ] ); // If you want to set a non-origin-form request target, set the // request-target explicitly: $request = $request-&gt;withRequestTarget((string) $uri); // absolute-form $request = $request-&gt;withRequestTarget($uri-&gt;getAuthority()); // authority-form $request = $request-&gt;withRequestTarget('*'); // asterisk-form // Once you have the instance: $request-&gt;getBody()-&gt;write(json_encode($data)); $response = $client-&gt;send($request); printf(\"Response status: %d (%s)\\n\", $response-&gt;getStatusCode(), $response-&gt;getReasonPhrase()); printf(\"Headers:\\n\"); foreach ($response-&gt;getHeaders() as $header =&gt; $values) { printf(\" %s: %s\\n\", $header, implode(', ', $values)); } printf(\"Message:\\n%s\\n\", $response-&gt;getBody()); (Note: laminas-diactoros does NOT ship with a client implementation; the above is just an illustration of a possible implementation.)","title":"HTTP Clients"},{"location":"v3/usage/#server-side-applications","text":"Server-side applications will need to marshal the incoming request based on superglobals, and will then populate and send a response.","title":"Server-Side Applications"}]}